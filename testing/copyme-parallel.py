"""
This example is from doi:10.1016/j.j.fuel.2015.02.018 Catalytic Combustion of
methane, methanol, and ethanol in microscale combustors with Pt/ZSM-5 packed beds

This is using reactor B
catalyst density = 0.038 mg/m^3
catalyst bed length = 20 mm
reactor length = 68 mm

surface to reactor volume ratio (assuming same active catalytic area) A/V, at 1600.0 m-1, from Ref 17
assume catalyst is a monolith, at 16.5 mm in diam, from Ref 17 & Ref 18
porosity is 0.81, from Ref 17
front heat sheild, cataylst, and back heat sheild is 10 mm long, from Ref 17
inlet mol flow at 0.208 mol/min
"""
# load a bunch of stuff
import cantera as ct
import numpy as np
import scipy
import pylab
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from matplotlib.pyplot import cm
from matplotlib.ticker import NullFormatter, MaxNLocator, LogLocator
plt.switch_backend('agg')  # needed for saving figures
import csv
from pydas.dassl import DASSL
import os
import rmgpy
import rmg
import re
import operator
import pandas as pd
import pylab
from cycler import cycler
import seaborn as sns
import os
import multiprocessing
import sys

# this chemkin file is from the cti generated by rmg
gas = ct.Solution('./chem_annotated.cti', 'gas')
surf = ct.Interface('./chem_annotated.cti', 'surface1', [gas])

print("This mechanism contains {} gas reactions and {} surface reactions".format(gas.n_reactions, surf.n_reactions))

# unit conversion factors to SI
mm = 0.001
cm = 0.01
ms = mm
minute = 60.0

#######################################################################
# Input Parameters
#######################################################################
t_in = 423.15  # K - 150 C gas inlet temp
t_cat = 773.15  # K - 500 C wall/catalyst temp

t_in = 773.15
# t_cat = 423.15

length = 48 * mm  # Reactor length - mm
diam = 4*mm  # Reactor diameter - mm
area = (diam/2.0)**2*np.pi  # Reactor cross section area (area of tube) in m^2
porosity = 0.095/2.85  # Monolith channel porosity, after loading pore volume / before loading pore volume?
cat_specific_area = 79.91  # m^2/g - pore surface, Table 1
pore_surface = 79.91  # m^2/g
pore_volume = 0.095e-6  # m^3/g, given as 0.095 mL/g
cat_area_per_vol = pore_surface/pore_volume  # HAN has it 2.8e7 m^2/m^3

# The PFR will be simulated by a chain of 'NReactors' stirred reactors.
NReactors = 4801  # reach reactor is 1e-2 mm long if nreactors is 6801

on_catalyst = 0  # catalyst starts at 20 mm
off_catalyst = 2000  # catalyst ends at 40 mm (20mm long)

reactor_len = length/(NReactors-1)  # find the length of each individual reactor, not including the last one
rvol = area * reactor_len * porosity  # each reactor's volume

# catalyst area in one reactor
cat_area = cat_area_per_vol * rvol  # the amount of catalyst per reactor volume

flow_rates_label = [100, 200, 300, 400, 500, 600]  # in mL/min
flow_rates = [x * 1e-6 / 60 for x in flow_rates_label]  # in m^3/s

def plotflow(a, flow_rate):
    """
    Given the output of a simulation, plot the species profiles through the PFR
    """
    gas_out, surf_out, gas_names, surf_names, dist_array, T_surf_array, T_gas_array = a

    # Plot in mol/min
    fig, axs = plt.subplots(1, 2)  # two plots

    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    for i in range(len(gas_out[0, :])):
        if gas_out[:, i].max() > 5.e-3:
            #             print(gas_names[i])
            axs[0].plot(dist_array, gas_out[:, i], label=gas_names[i])
            species_name = gas_names[i]
            if species_name.endswith(')'):
                if species_name[-3] == '(':
                    species_name = species_name[0:-3]
                else:
                    species_name = species_name[0:-4]
            # if species_name == "O2":
            #     axs[0].annotate("O$_2$", fontsize=14, color='y',
            #                     xy=(dist_array[500], gas_out[:, i][500] + gas_out[:, i][500] / 100.0),
            #                     va='bottom', ha='center')
            # elif species_name == "CO2":
            #     axs[0].annotate("CO$_2$", fontsize=14, color='c',
            #                     xy=(dist_array[2300], gas_out[:, i][5000] + gas_out[:, i][5000] / 10.0), va='bottom',
            #                     ha='center')
            # elif species_name == "CO":
            #     axs[0].annotate("CO", fontsize=14, color='g', xy=(dist_array[6000], gas_out[:, i][6000] + 0.001),
            #                     va='bottom', ha='center')
            # elif species_name == "H2":
            #     axs[0].annotate("H$_2$", fontsize=14, color='k', xy=(dist_array[6000], gas_out[:, i][6000] - 0.001),
            #                     va='top', ha='center')
            # elif species_name == "CH4":
            #     axs[0].annotate("CH$_4$", fontsize=14, color='b',
            #                     xy=(dist_array[500], gas_out[:, i][500] + gas_out[:, i][500] / 100.0),
            #                     va='bottom', ha='center')
            # elif species_name == "H2O":
            #     axs[0].annotate("H$_2$O", fontsize=14, color='r',
            #                     xy=(dist_array[5000], gas_out[:, i][5000] + gas_out[:, i][5000] / 40.0 + 0.001), va='bottom',
            #                     ha='center')
            # else:
            #     axs[0].annotate(species_name, fontsize=14,
            #                     xy=(dist_array[-1], gas_out[:, i][-1] + gas_out[:, i][-1] / 10.0), va='top',
            #                     ha='center')
        else:
            axs[0].plot(0, 0)

    axs[1].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))
    axs[1].plot(dist_array, T_surf_array, label="surf temp")
    axs[1].plot(dist_array, T_gas_array, label="gas temp")

    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    # axs[0].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [0, 0.3], linestyle='--', color='xkcd:grey')
    # axs[0].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [0, 0.3], linestyle='--', color='xkcd:grey')
    # axs[0].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 0.275), va='bottom', ha='left')
    # axs[1].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [400.0, 2500], linestyle='--', color='xkcd:grey')
    # axs[1].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [400.0, 2500], linestyle='--', color='xkcd:grey')
    # axs[1].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 500), va='bottom', ha='left')

    for item in (
            axs[0].get_xticklabels() + axs[0].get_yticklabels() + axs[1].get_xticklabels() + axs[1].get_yticklabels()):
        item.set_fontsize(12)

    axs[1].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=2)
    axs[0].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=4)
    # axs[0].set_ylim(0., 0.15)
    # axs[1].set_ylim(400.0, 2400)
    # axs[0].set_xlim(0.0, length / mm)
    # axs[1].set_xlim(0.0, length / mm)
    axs[0].set_xlabel('Distance (mm)', fontsize=13)
    axs[1].set_xlabel('Distance (mm)', fontsize=13)  # axs[0,1].set_xlabel('time (s)'); axs[1,1].set_xlabel('time (s)')
    axs[0].set_ylabel('flow/ mol/min', fontsize=13)
    axs[1].set_ylabel('Temperature (K)', fontsize=13)
    fig.set_figheight(6)
    fig.set_figwidth(18)

    # getting the input gas ratios

    out_dir = 'figures'
    os.path.exists(out_dir) or os.makedirs(out_dir)
    fig.savefig(out_dir + '/' + str(flow_rate) + 'flow_rate.pdf', bbox_inches='tight')


def plotZoom(a, flow_rate):
    """
    A zoomed in version of plotFlow, takes all the same inputs
    """
    gas_out, surf_out, gas_names, surf_names, dist_array, T_array = a

    fig, axs = plt.subplots(1, 2)
    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    for i in range(len(gas_out[0, :])):
        if gas_out[:, i].max() > 5.e-3:
            #             print(gas_names[i])
            axs[0].plot(dist_array, gas_out[:, i], label=gas_names[i])
            species_name = gas_names[i]
            if species_name.endswith(')'):
                if species_name[-3] == '(':
                    species_name = species_name[0:-3]
                else:
                    species_name = species_name[0:-4]
            if species_name == "O2":
                axs[0].annotate("O$_2$", fontsize=14, color='y',
                                xy=(dist_array[1100], gas_out[:, i][1100] + gas_out[:, i][1100] / 100.0),
                                va='bottom', ha='center')
            elif species_name == "CO2":
                axs[0].annotate("CO$_2$", fontsize=14, color='c',
                                xy=(dist_array[2400], gas_out[:, i][2400] + gas_out[:, i][2400] / 10.0), va='bottom',
                                ha='center')
            elif species_name == "CO":
                axs[0].annotate("CO", fontsize=14, color='g', xy=(dist_array[2100], gas_out[:, i][2100] + 0.001),
                                va='bottom', ha='center')
            elif species_name == "H2":
                axs[0].annotate("H$_2$", fontsize=14, color='k', xy=(dist_array[2200], gas_out[:, i][2200] - 0.001),
                                va='top', ha='center')
            elif species_name == "CH4":
                axs[0].annotate("CH$_4$", fontsize=14, color='b',
                                xy=(dist_array[1100], gas_out[:, i][1100] + gas_out[:, i][1100] / 100.0),
                                va='bottom', ha='center')
            elif species_name == "H2O":
                axs[0].annotate("H$_2$O", fontsize=14, color='r',
                                xy=(dist_array[2100], gas_out[:, i][2100] + gas_out[:, i][2100] / 40.0 + 0.001), va='bottom',
                                ha='center')
            else:
                axs[0].annotate(species_name, fontsize=14,
                                xy=(dist_array[-1], gas_out[:, i][-1] + gas_out[:, i][-1] / 10.0), va='top',
                                ha='center')
        else:
            axs[0].plot(0, 0)

    axs[1].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))
    # Plot two temperatures (of gas-phase and surface vs only surface.)
    # axs[1].plot(dist_array, T_array, label="temperature")
    ax2 = axs[0].twinx()
    ax2.plot(dist_array, T_array, label='temperature', color='r', linestyle=':')
    #     axs[1].plot(dist_array, T2_array, "--", label="surface reactions only")
    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    axs[0].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [0, 0.2], linestyle='--', color='xkcd:grey')
    axs[0].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [0, 0.2], linestyle='--', color='xkcd:grey')
    axs[0].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 0.175), va='bottom', ha='left')
    axs[1].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [600.0, 2000], linestyle='--', color='xkcd:grey')
    axs[1].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [600.0, 2000], linestyle='--', color='xkcd:grey')
    axs[1].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 1800), va='bottom', ha='left')

    for item in (
            axs[0].get_xticklabels() + axs[0].get_yticklabels() + ax2.get_xticklabels() + ax2.get_yticklabels()):
        item.set_fontsize(18)

    #axs[1].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=2)
    axs[0].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=4)
    # axs[0].set_ylim(0., 0.1)
    # axs[1].set_ylim(600.0, 2000)
    # axs[0].set_xlim(8, 25)
    # axs[1].set_xlim(8, 25)
    axs[0].set_xlabel('Distance (mm)', fontsize=20)
    axs[1].set_xlabel('Distance (mm)', fontsize=20)  # axs[0,1].set_xlabel('time (s)'); axs[1,1].set_xlabel('time (s)')
    axs[0].set_ylabel('flow/ mol/min', fontsize=20)
    # axs[1].set_ylabel('Temperature (K)', fontsize=20)
    ax2.set_ylabel('Temperature (K)', fontsize=20)
    # ax2.set_ylim(600, 2000)
    # ax2.set_xlim(8, 25)
    fig.set_figheight(6)
    fig.set_figwidth(24)

    out_dir = 'figures'
    os.path.exists(out_dir) or os.makedirs(out_dir)
    fig.savefig(out_dir + '/' + str(flow_rate) + 'flow_rateZoom.pdf', bbox_inches='tight')


def plotSurf(a, flow_rate):
    """
    Plot the surface species' profiles throughout the PFR
    """
    gas_out, surf_out, gas_names, surf_names, dist_array, T_array = a

    fig, axs = plt.subplots(1, 2)
    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    for i in range(len(gas_out[0, :])):
        if gas_out[:, i].max() > 5.e-3:
            #             print(gas_names[i])
            axs[0].plot(dist_array, gas_out[:, i], label=gas_names[i])
            species_name = gas_names[i]
            if species_name.endswith(')'):
                if species_name[-3] == '(':
                    species_name = species_name[0:-3]
                else:
                    species_name = species_name[0:-4]
            if species_name == "O2":
                axs[0].annotate("O$_2$", fontsize=12,
                                xy=(dist_array[2200], gas_out[:, i][2200] + gas_out[:, i][2200] / 100.0),
                                va='bottom', ha='center')
            elif species_name == "CO2":
                axs[0].annotate("CO$_2$", fontsize=12,
                                xy=(dist_array[2200], gas_out[:, i][2200] + gas_out[:, i][2200] / 10.0), va='top',
                                ha='center')
            elif species_name == "CO":
                axs[0].annotate("CO", fontsize=12, xy=(dist_array[2200], gas_out[:, i][2200] + 0.001),
                                va='bottom', ha='center')
            elif species_name == "CH2O":
                axs[0].annotate("CH$_2$O", fontsize=12, xy=(dist_array[2200], gas_out[:, i][2200] + 0.001),
                                va='bottom', ha='center')
            elif species_name == "CH4":
                axs[0].annotate("CH$_4$", fontsize=12,
                                xy=(dist_array[2200], gas_out[:, i][2200] + gas_out[:, i][2200] / 100.0),
                                va='bottom', ha='center')
            elif species_name == "H2O":
                axs[0].annotate("H$_2$O", fontsize=12,
                                xy=(dist_array[2200], gas_out[:, i][2200] + gas_out[:, i][2200] / 40.0), va='top',
                                ha='center')
            else:
                axs[0].annotate(species_name, fontsize=12,
                                xy=(dist_array[-1], gas_out[:, i][-1] + gas_out[:, i][-1] / 10.0), va='top',
                                ha='center')
        else:
            axs[0].plot(0, 0)

    axs[1].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))
    # Plot two temperatures (of gas-phase and surface vs only surface.)
    for i in range(len(surf_out[0, :])):
        if surf_out[:, i].max() > 5.e-3:
            axs[1].plot(dist_array, surf_out[:, i], label=surf_names[i])
    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    axs[0].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [0, 0.2], linestyle='--', color='xkcd:grey')
    axs[0].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [0, 0.2], linestyle='--', color='xkcd:grey')
    axs[0].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 0.175), va='bottom', ha='left')
    axs[1].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [0, 1.2], linestyle='--', color='xkcd:grey')
    axs[1].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [0, 1.2], linestyle='--', color='xkcd:grey')
    axs[1].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 1.1), va='bottom', ha='left')

    for item in (
            axs[0].get_xticklabels() + axs[0].get_yticklabels() + axs[1].get_xticklabels() + axs[1].get_yticklabels()):
        item.set_fontsize(12)

    axs[1].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=2)
    axs[0].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=4)
    # axs[0].set_ylim(0., 0.1)
    # axs[1].set_ylim(0, 1.2)
    # axs[0].set_xlim(5, 25)
    # axs[1].set_xlim(5, 25)
    axs[0].set_xlabel('Distance (mm)', fontsize=13)
    axs[1].set_xlabel('Distance (mm)', fontsize=13)  # axs[0,1].set_xlabel('time (s)'); axs[1,1].set_xlabel('time (s)')
    axs[0].set_ylabel('flow/ mol/min', fontsize=13)
    axs[1].set_ylabel('Site fraction', fontsize=13)
    # fig.tight_layout()
    # axs[1,0].ticklabel_format(axis='x', style='sci', scilimits=(0,0))
    # axs[0,1].ticklabel_format(axis='x', style='sci', scilimits=(0,0))
    # axs[1,1].ticklabel_format(axis='x', style='sci', scilimits=(0,0))
    fig.set_figheight(6)
    fig.set_figwidth(18)

    #

    out_dir = 'figures'
    os.path.exists(out_dir) or os.makedirs(out_dir)
    fig.savefig(out_dir + '/' + str(flow_rate) + 'flow_rateSurf.pdf', bbox_inches='tight')

def monolithFull(gas, surf, t_in, t_cat, flow_rate, verbose=False, sens=False):
    """
    Verbose prints out values as you go along
    Sens is for sensitivity, in the form [perturbation, reaction #]

    This runs each individual simulation
    """
    X = str('CH3OH(2):0.122807, N2:0.692983, O2(4):0.18421')  # equivalence ratio of 1.0
    gas.TPX = t_in, ct.one_atm, X  # need to initialize mass flow rate at 150 C
    # mass_flow_rate = velocity * gas.density_mass * area  # kg/s
    mass_flow_rate = flow_rate * gas.density_mass
    surf.TP = t_cat, ct.one_atm
    surf.coverages = 'X(1):1.0'
    gas.set_multiplier(1.0)

    TDY = gas.TDY
    cov = surf.coverages

    if verbose is True:  # setting up how things will print out if it is wanted
        print('  distance(mm)   X_CH4        X_O2        X_H2       X_CO       X_H2O       X_CO2')

    # create a new reactor
    gas.TDY = TDY
    r = ct.IdealGasReactor(gas, energy='on')  # energy is on by default
    r.volume = rvol

    # create a reservoir to represent the reactor immediately upstream. Note
    # that the gas object is set already to the state of the upstream reactor
    upstream = ct.Reservoir(gas, name='upstream')

    # create a reservoir for the reactor to exhaust into. The composition of
    # this reservoir is irrelevant.
    downstream = ct.Reservoir(gas, name='downstream')

    # Add the reacting surface to the reactor. The area is set to the desired
    # catalyst area in the reactor.
    rsurf = ct.ReactorSurface(surf, r, A=cat_area)

    # The mass flow rate into the reactor will be fixed by using a
    # MassFlowController object.
    m = ct.MassFlowController(upstream, r, mdot=mass_flow_rate)

    # We need an outlet to the downstream reservoir. This will determine the
    # pressure in the reactor. The value of K will only affect the transient
    # pressure difference.
    v = ct.PressureController(r, downstream, master=m, K=1e-5)

    sim = ct.ReactorNet([r])
    sim.max_err_test_fails = 12

    # set relative and absolute tolerances on the simulation
    # these vary on the type of computer used and are super annoying so good luck
    sim.rtol = 1.0e-10
    sim.atol = 1.0e-20

    gas_names = gas.species_names  # save the gas species names
    surf_names = surf.species_names  # save the surface species' names
    gas_out = []  # save the gas species concentrations

    # arrays to store the useful information in
    surf_out = []
    dist_array = []
    T_surf_array = []  # wall temp
    T_gas_array = []

    surf.set_multiplier(0.0)  # no surface reactions until the gauze/catalyst
    print('n    surfT    gasT')
    for n in range(NReactors):
        # Set the state of the reservoir to match that of the previous reactor
        gas.TDY = r.thermo.TDY
        print(n, surf.T, gas.T)
        upstream.syncState()
        if n == on_catalyst:  # turn the catalyst `on'
            surf.set_multiplier(1.0)
            if sens is not False:
                surf.set_multiplier(1.0 + sens[0], sens[1])
        if n == off_catalyst:  # turn the catalyst `off'
            surf.set_multiplier(0.0)
        sim.reinitialize()
        # sim.advance_to_steady_state()
        sim.advance_to_steady_state(residual_threshold=3, atol=3)
        dist = n * reactor_len  * 1e3  # distance in m
        dist_array.append(dist)
        T_surf_array.append(surf.T)
        T_gas_array.append(gas.T)
        kmole_flow_rate = mass_flow_rate / gas.mean_molecular_weight  # kmol/s
        gas_out.append(1000 * 60 * kmole_flow_rate * gas.X.copy())  # molar flow rate in moles/minute
        surf_out.append(surf.X.copy())

        # make reaction diagrams
        out_dir = 'rxnpath'
        os.path.exists(out_dir) or os.makedirs(out_dir)
        elements = ['H', 'O', 'C']
        locations_of_interest = [0, 1000, 2001, 4800]
        if sens is False:
            for l in locations_of_interest:
                if n == l:
                    location = str(int(n / 100))

                    diagram = ct.ReactionPathDiagram(surf, 'X')
                    diagram.title = 'rxn path'
                    diagram.label_threshold = 1e-9
                    dot_file = out_dir + '/rxnpath-' + str(flow_rate) + '-x-' + location + 'mm.dot'
                    img_file = out_dir + '/rxnpath-' + str(flow_rate) + '-x-' + location + 'mm.png'
                    img_path = os.path.join(out_dir, img_file)
                    diagram.write_dot(dot_file)
                    os.system('dot {0} -Tpng -o{1} -Gdpi=200'.format(dot_file, img_file))

                    for element in elements:
                        diagram = ct.ReactionPathDiagram(surf, element)
                        diagram.title = element + 'rxn path'
                        diagram.label_threshold = 1e-9
                        dot_file = out_dir + '/rxnpath-' + str(flow_rate) + '-surf-' + location + 'mm-' + element + '.dot'
                        img_file = out_dir + '/rxnpath-' + str(flow_rate) + '-surf-' + location + 'mm-' + element + '.png'
                        img_path = os.path.join(out_dir, img_file)
                        diagram.write_dot(dot_file)
                        os.system('dot {0} -Tpng -o{1} -Gdpi=200'.format(dot_file, img_file))
        else:
            pass

        if verbose is True:  # print out gas profiles at certain times if the user so desires
            if not n % 100:
                print('  {0:10f}  {1:10f}  {2:10f}  {3:10f} {4:10f} {5:10f} {6:10f}'.format(dist, *gas[
                    'CH4(2)', 'O2(3)', 'H2(6)', 'CO(7)', 'H2O(5)', 'CO2(4)'].X * 1000 * 60 * kmole_flow_rate))

    # save the things at the end or each reactor
    gas_out = np.array(gas_out)
    surf_out = np.array(surf_out)
    gas_names = np.array(gas_names)
    surf_names = np.array(surf_names)
    data_out = gas_out, surf_out, gas_names, surf_names, dist_array, T_surf_array, T_gas_array
    return data_out


def simulationWorker(flow_rate):
    """
    Start all of the simulations all at once using multiprocessing
    """
    try:  # make a try loop because of CVODES errors
        a = monolithFull(gas, surf, t_in, t_cat, flow_rate)
        print("Finished simulation at a flow rate of {:.1f}".format(flow_rate))
        gas_out, surf_out, gas_names, surf_names, dist_array, T_surf_array, T_gas_array = a
        plotflow(a, flow_rate)
        plotZoom(a, flow_rate)
        plotSurf(a, flow_rate)
        return [flow_rate, [gas_out, gas_names, dist_array, T_array]]
    except Exception as e: print(str(e))
        # print('Unable to run simulation at a flow rate of {:.1f}'.format(flow_rate))
        # pass

flow_rates = [x * 1e-6 / 60 for x in flow_rates]
# data = []
# num_threads = len(flow_rates)
# pool = multiprocessing.Pool(processes=num_threads)
# data = pool.map(simulationWorker, flow_rates, 1)  # start the simulations in parallel
# pool.close()
# pool.join()

a = monolithFull(gas, surf, t_in, t_cat, flow_rates[0])
plotflow(a, flow_rates_label[0])
# plotZoom(a, flow_rates_label[0])
# plotSurf(a, flow_rates_label[0])

sys.exit('stop here')

# # finding exit conversions
# # this is a horrible, inefficient way to do this but it works for now.  Let's hope I fix it before this code is published
# end_temp = []
# max_temp = []
# dist_max_temp = []
# ch4_in = []
# ch4_out = []
# ch4_conv = []
# o2_conv = []
# co_sel = []
# co_out = []
# h2_sel = []
# h2_out = []
# h2o_sel = []
# h2o_out = []
# co2_sel = []
# co2_out = []
# ratios_real = []
# for r in data:
#     # gas_out,gas_names,dist_array,T_array = r[1]
#     for x in range(len(r[1][1])):
#         if r[1][1][x] == 'CH4(2)':
#             ch4_i = r[1][0][0][x]
#             ch4_in.append(ch4_i)
#             ch4_o = r[1][0][-1][x]
#             if ch4_o < 0:
#                 ch4_o = 0.
#             ch4_out.append(ch4_o)
#             ch4_depletion = ch4_i - ch4_o
#             if ch4_depletion <= 0:
#                 ch4_depletion = 0.
#             ch4_conv.append(ch4_depletion / ch4_i)
#         if r[1][1][x] == 'O2(3)':
#             o2_in = r[1][0][0][x]
#             o2_out = r[1][0][-1][x]
#             if o2_out < 0:
#                 o2_out = 0.
#             elif o2_out > o2_in:
#                 o2_out = o2_in
#             conv = (o2_in - o2_out) / o2_in
#             if conv < 0:
#                 o2_conv.append(0.)
#             else:
#                 o2_conv.append(conv)
#     ratios_real.append(ch4_i / (2 * o2_in))
#     end_temp.append(r[1][3][-1])
#     max_temp.append(max(r[1][3]))
#     dist_max_temp.append(r[1][2][r[1][3].index(max(r[1][3]))])
#
#     for x in range(len(r[1][1])):
#         if r[1][1][x] == 'Ar':
#             ar = r[1][0][-1][x]
#         if r[1][1][x] == 'CO(7)':
#             co_o = r[1][0][-1][x]
#             co_out.append(co_o)
#             co_sel.append(co_o / ch4_depletion)
#         if r[1][1][x] == 'H2O(5)':
#             h2o_o = r[1][0][-1][x]
#             h2o_out.append(h2o_o)
#             h2o_sel.append(h2o_o / (ch4_depletion * 2))
#         if r[1][1][x] == 'H2(6)':
#             h2_o = r[1][0][-1][x]
#             h2_out.append(h2_o)
#             h2_sel.append(h2_o / (ch4_depletion * 2))
#         if r[1][1][x] == 'CO2(4)':
#             co2_o = r[1][0][-1][x]
#             co2_out.append(co2_o)
#             co2_sel.append(co2_o / ch4_depletion)
#
# output = []
# for x in range(len(ratios_real)):
#     output.append([ratios_real[x], ch4_in[x], ch4_out[x], co_out[x], h2_out[x], h2o_out[x], co2_out[x], end_temp[x], max_temp[x], dist_max_temp[x], o2_conv[x]])
# k = (pd.DataFrame.from_dict(data=output, orient='columns'))
# k.columns = ['C/O ratio', 'CH4 in', 'CH4 out', 'CO out', 'H2 out', 'H2O out', 'CO2 out', 'Exit temp', 'Max temp', 'Dist to max temp', 'O2 conv']
# k.to_csv('dict_conversions_selectivities.csv', header=True)  # export the original simulation results to a csv in case things go wrong
#
# # plot the simulation results over different ratios
# fig, axs = plt.subplots(1, 2)
# # plot exit conversion and temp
# axs[0].plot(ratios_real, ch4_conv, 'bo-', label='CH4', color='limegreen')
# axs[0].plot(ratios_real, o2_conv, 'bo-', label='O2', color='blue')
# ax2 = axs[0].twinx()
# ax2.plot(ratios_real, end_temp, 'bo-', label='temp', color='orange')
# ax2.set_ylim(600.0, 2000)
# # plot exit selectivities
# axs[1].plot(ratios_real, co_sel, 'bo-', label='CO', color='green')
# axs[1].plot(ratios_real, h2_sel, 'bo-', label='H2', color='purple')
# axs[1].plot(ratios_real, co2_sel, 'bo-', label='CO2', color='navy')
# axs[1].plot(ratios_real, h2o_sel, 'bo-', label='H2O', color='dodgerblue')
# axs[0].legend()
# axs[1].legend()
# axs[0].set_ylabel('Exit conversion (%)', fontsize=13)
# ax2.set_ylabel('Exit temperature (K)', fontsize=13)
# axs[0].set_xlabel('C/O Ratio', fontsize=13)
# axs[1].set_xlabel('C/O Ratio', fontsize=13)
# axs[1].set_ylabel('Exit selectivity (%)', fontsize=13)
# plt.tight_layout()
# fig.set_figheight(6)
# fig.set_figwidth(16)
# out_dir = 'figures'
# os.path.exists(out_dir) or os.makedirs(out_dir)
# fig.savefig(out_dir + '/' + 'conversion&selectivity.pdf', bbox_inches='tight')
#
# # comparing all species profiles, all in one
# temps = []
# o2 = []
# co = []
# h2 = []
# ratios = []
# for r in data:
#     gas_out, gas_names, dist_array, T_array = r[1]
#     for x in range(len(r[1][1])):
#         if r[1][1][x] == 'O2(3)':
#             o2.append(r[1][0][:, x])
#         if r[1][1][x] == 'CO(7)':
#             co.append(r[1][0][:, x])
#         if r[1][1][x] == 'H2(6)':
#             h2.append(r[1][0][:, x])
#     dist_array = r[1][2]
#     temps.append(r[1][3])
#     ratios.append(r[0])
#
# sns.set_palette(sns.color_palette("hls", 15))
# fig, axs = plt.subplots(3, 1)
# # plot exit conversion and temp
# for r in range(len(ratios)):
#     axs[0].plot(dist_array, o2[r], label=ratios[r])
#     axs[1].plot(dist_array, h2[r], label=ratios[r])
#     axs[2].plot(dist_array, co[r], label=ratios[r])
# ax2 = axs[0].twinx()
# for r in range(len(ratios)):
#     ax2.plot(dist_array, temps[r])
# axs[0].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [-0.02, 0.2], linestyle='--', color='xkcd:grey')
# axs[0].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [-0.02, 0.2], linestyle='--', color='xkcd:grey')
# axs[0].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 0.08), va='bottom', ha='left')
# axs[0].legend(loc='center left')
# axs[0].set_ylabel('O2 Flow (mol/mm)', fontsize=13)
# ax2.set_ylabel('Temperature (K)', fontsize=13)
# axs[0].set_xlabel('Position (mm)', fontsize=13)
# axs[1].set_ylabel('H2 Flow (mol/min)', fontsize=13)
# axs[2].set_ylabel('CO Flow (mol/min)', fontsize=13)
# axs[1].set_xlabel('Position (mm)', fontsize=13)
# axs[2].set_xlabel('Position (mm)', fontsize=13)
# ax2.set_ylim(200, 2000)
# axs[0].set_ylim(0, .1)
# axs[0].set_xlim(5, 25)
# axs[1].set_xlim(5, 25)
# axs[2].set_xlim(5, 25)
# fig.set_figheight(14)
# fig.set_figwidth(8)
# out_dir = 'figures'
# os.path.exists(out_dir) or os.makedirs(out_dir)
# fig.savefig(out_dir + '/' + 'flows.pdf', bbox_inches='tight')
#
#
# ###################
# # SENSITIVITY
# ###################
#
#
# def sensitivity(gas, surf, old_data, temp, dk, thermo=False):
#     """
#     Function to get sensitivity, but running additional simulations and comparing
#     to the original simulation (data) to get a numberical value for sensitivity.
#
#     old_data is an array with the original simulation output.
#
#     Has multiple ways to calculate sensitivity.  You can use all at once, but was
#     written so that the other ways could be commented out.  I apologize
#     """
#     rxns = []
#     sens1 = []
#     sens2 = []
#     sens3 = []
#     sens4 = []
#     sens5 = []
#     sens6 = []
#     sens7 = []
#     sens8 = []
#     sens9 = []
#     sens10 = []
#     sens11 = []
#     sens12 = []
#     sens13 = []
#
#     gas_out_data, gas_names_data, dist_array_data, T_array_data = old_data  # unpacking
#
#     reference = []
#     for a in range(len(gas_names_data)):
#         reference.append([gas_names_data[a], [gas_out_data[:, a]]])
#
#     # getting the ratio
#     for x in reference:
#         if x[0] == 'CH4(2)':
#             ch4_in = x[1][0][0]
#         if x[0] == 'O2(3)':
#             o2_in = x[1][0][0]
#         if x[0] == 'Ar':
#             ar_in = x[1][0][0]
#     ratio = ch4_in / (2 * o2_in)
#     moles_in = [ch4_in, o2_in, ar_in]
#
#     # calculating things from the original simulations
#     for x in reference:
#         if x[0] == 'CH4(2)':
#             ch4_in = x[1][0][0]
#             ch4_out = x[1][0][-1]
#             if ch4_out < 0:
#                 ch4_out = 0.
#             ch4_depletion = ch4_in - ch4_out
#             if ch4_depletion <= 1.0e-8:
#                 ch4_depletion = 1.0e-8
#                 reference_ch4_conv = 1.0e-8
#             else:
#                 reference_ch4_conv = ch4_depletion / ch4_in  # Sensitivity definition 7: CH4 conversion
#         if x[0] == 'Ar':
#             ar = x[1][0][-1]
#         if x[0] == 'O2(3)':
#             o2_in = x[1][0][0]
#             o2_out = x[1][0][-1]
#             if o2_out < 0:
#                 o2_out = 0.  # O2 can't be negative
#             elif o2_out > o2_in:
#                 o2_out = o2_in  # O2 can't be created, to make it equal to O2 in
#             o2_depletion = o2_in - o2_out
#             if o2_depletion <= 1.0e-8:
#                 o2_depletion = 1.0e-8
#                 reference_o2_conv = 1.0e-8
#             else:
#                 reference_o2_conv = o2_depletion / o2_in  # Sensitivity definition 13: O2 conversion
#         if x[0] == 'CO(7)':
#             co_out = x[1][0][-1]
#         if x[0] == 'H2(6)':
#             h2_out = x[1][0][-1]
#         if x[0] == 'H2O(5)':
#             h2o_out = x[1][0][-1]
#         if x[0] == 'CO2(4)':
#             co2_out = x[1][0][-1]
#
#     # if things are to small to make a difference, make them basically zero but also not give a divide by zero error
#     if reference_ch4_conv <= 1.0e-8:
#         reference_h2_sel = 1.0e-8
#         reference_co_sel = 1.0e-8
#         reference_syngas_selectivity = 1.0e-8
#         reference_syngas_yield = 1.0e-8
#         reference_co_yield = 1.0e-8
#         reference_h2_yield = 1.0e-8
#         reference_full_oxidation_selectivity = 1.0e-8
#         reference_full_oxidation_yield = 1.0e-8
#         reference_o2_conv = 1.0e-8
#     else:
#         # negative sensitivity is higher selectivity
#         reference_h2_sel = h2_out / (ch4_depletion * 2)  # Sensitivity definition 5: H2 selectivity
#         if reference_h2_sel <= 0:
#             reference_h2_sel = 1.0e-15  # selectivity can't be 0
#
#         reference_co_sel = co_out / ch4_depletion  # Sensitivity definition 3: CO selectivity
#         if reference_co_sel <= 0:
#             reference_co_sel = 1.0e-15  # selectivity can't be 0
#
#         reference_syngas_selectivity = reference_co_sel + reference_h2_sel  # Sensitivity definition 1: SYNGAS selectivity
#
#         reference_syngas_yield = reference_syngas_selectivity * reference_ch4_conv  # Sensitivity definition 2: SYNGAS yield
#         if reference_syngas_yield <= 0:
#             reference_syngas_yield = 1.0e-15  # yield can't be 0
#
#         reference_co_yield = co_out / ch4_in  # Sensitivity definition 4: CO % yield
#         # reference_co_yield = reference_co_sel * reference_ch4_conv
#
#         reference_h2_yield = h2_out / (2 * ch4_in)  # Sensitivity definition 6: H2 % yield
#         # reference_h2_yield = reference_h2_sel * reference_ch4_conv
#
#         # Sensitivity definition 8: H2O + CO2 selectivity
#         reference_h2o_sel = h2o_out / (ch4_depletion * 2)
#         reference_co2_sel = co2_out / ch4_depletion
#         if reference_h2o_sel <= 0:
#             reference_h2o_sel = 1.0e-15  # H2O selectivity can't be 0
#         if reference_co2_sel <= 0:
#             reference_co2_sel = 1.0e-15  # CO2 selectivity can't be 0
#         reference_full_oxidation_selectivity = reference_h2o_sel + reference_co2_sel
#
#         # Sensitivity definition 9: H2O + CO2 yield
#         reference_full_oxidation_yield = reference_full_oxidation_selectivity * reference_ch4_conv
#
#     # Sensitivity definition 10: exit temperature
#     reference_exit_temp = T_array_data[-1]
#
#     # Sensitivity definition 11: peak temperature
#     reference_peak_temp = max(T_array_data)
#
#     # Sensitivity definition 12: distance to peak temperautre
#     reference_peak_temp_dist = dist_array_data[T_array_data.index(max(T_array_data))]
#
#     # run the simulations
#     if thermo is True:  # thermo sensitivity stuff, all off by default and was not referenced in the paper
#         # this should also be rewritten to be less repetitive
#         dH = 1e4 # J/mol
#         dk = dH / 8.314  # for the thermo loop, 'dk' is in fact (delta H / R)
#         for m in range(surf.n_species):
#             s = surf.species(m)
#             original_coeffs = s.thermo.coeffs
#             perturbed_coeffs = np.ones_like(original_coeffs)
#             perturbed_coeffs[0] = original_coeffs[0]
#             perturbed_coeffs[1:6] = original_coeffs[1:6]
#             perturbed_coeffs[7:13] = original_coeffs[7:13]
#             perturbed_coeffs[14] = original_coeffs[14]
#             perturbed_coeffs[6] = original_coeffs[6] + dk
#             perturbed_coeffs[13] = original_coeffs[13] + dk
#             s.thermo = ct.NasaPoly2(100.000, 5000.000, ct.one_atm, perturbed_coeffs)
#             surf.modify_species(m, s)
#             c = monolithFull(gas, surf, temp, moles_in)  # run the simulation
#
#             gas_out, surf_out, gas_names, surf_names, dist_array, T_array = c  # unpack
#
#             new_amts = []
#             for a in range(len(gas_names)):
#                 new_amts.append([gas_names[a], [gas_out[:, a]]])
#
#             for x in new_amts:
#                 if x[0] == 'CH4(2)':
#                     new_ch4_in = x[1][0][0]
#                     new_ch4_out = x[1][0][-1]
#                     if new_ch4_out < 0:
#                         new_ch4_out = 0.
#                     new_ch4_depletion = new_ch4_in - new_ch4_out
#                     if new_ch4_depletion <= 1e-8:
#                         new_ch4_depletion = 1e-8
#                         new_ch4_conv = 1e-8
#                     else:
#                         new_ch4_conv = new_ch4_depletion / new_ch4_in  # Sensitivity definition 7: CH4 conversion
#                 if x[0] == 'Ar':
#                     ar = x[1][0][-1]
#                 if x[0] == 'O2(3)':
#                     new_o2_in = x[1][0][0]
#                     new_o2_out = x[1][0][-1]
#                     if new_o2_out < 0:
#                         new_o2_out = 0.
#                     elif new_o2_out > new_o2_in:
#                         new_o2_out = new_o2_in
#                     new_o2_depletion = new_o2_in - new_o2_out
#                     if new_o2_depletion <= 1.0e-8:
#                         new_o2_depletion = 1.0e-8
#                         new_o2_conv = 1.0e-8
#                     else:
#                         new_o2_conv = new_o2_depletion / new_o2_in
#                 if x[0] == 'CO(7)':
#                     new_co_out = x[1][0][-1]
#                 if x[0] == 'H2(6)':
#                     new_h2_out = x[1][0][-1]
#                 if x[0] == 'H2O(5)':
#                     new_h2o_out = x[1][0][-1]
#                 if x[0] == 'CO2(4)':
#                     new_co2_out = x[1][0][-1]
#
#             if new_ch4_conv <= 1e-8:
#                 new_h2_sel = 1.0e-8
#                 new_co_sel = 1.0e-8
#                 new_syngas_selectivity = 1.0e-8
#                 new_syngas_yield = 1.0e-8
#                 new_co_yield = 1.0e-8
#                 new_h2_yield = 1.0e-8
#                 new_full_oxidation_selectivity = 1.0e-8
#                 new_full_oxidation_yield = 1.0e-8
#                 new_o2_conv = 1e-8
#             else:
#                 new_h2_sel = new_h2_out / (new_ch4_depletion * 2)  # Sensitivity definition 5: H2 selectivity
#                 new_co_sel = new_co_out / new_ch4_depletion  # Sensitivity definition 3: CO selectivity
#                 new_syngas_selectivity = new_co_sel + new_h2_sel  # Sensitivity definition 1: SYNGAS selectivity
#                 new_syngas_yield = new_syngas_selectivity * new_ch4_conv  # Sensitivity definition 2: SYNGAS yield
#                 new_co_yield = new_co_out / new_ch4_in  # Sensitivity definition 4: CO % yield
#                 new_h2_yield = new_h2_out / (2 * new_ch4_in)  # Sensitivity definition 6: H2 % yield
#                 new_h2o_sel = new_h2o_out / (new_ch4_depletion * 2)  # Sensitivity definition 8: H2O + CO2 selectivity
#                 new_co2_sel = new_co2_out / new_ch4_depletion
#                 new_full_oxidation_selectivity = new_h2o_sel + new_co2_sel
#                 new_full_oxidation_yield = new_full_oxidation_selectivity * new_ch4_conv  # Sensitivity definition 9: C2O + CO2 yield
#
#             Sens5 = (new_h2_sel - reference_h2_sel) / (reference_h2_sel * dk)
#             sens5.append(Sens5)
#
#             Sens3 = (new_co_sel - reference_co_sel) / (reference_co_sel * dk)
#             sens3.append(Sens3)
#
#             Sens1 = (new_syngas_selectivity - reference_syngas_selectivity) / (reference_syngas_selectivity * dk)
#             sens1.append(Sens1)
#
#             Sens2 = (new_syngas_yield - reference_syngas_yield) / (reference_syngas_yield * dk)
#             sens2.append(Sens2)
#
#             Sens4 = (new_co_yield - reference_co_yield) / (reference_co_yield * dk)
#             sens4.append(Sens4)
#
#             Sens6 = (new_h2_yield - reference_h2_yield) / (reference_h2_yield * dk)
#             sens6.append(Sens6)
#
#             Sens7 = (new_ch4_conv - reference_ch4_conv) / (
#                         reference_ch4_conv * dk)
#             sens7.append(Sens7)
#
#             Sens13 = (new_o2_conv - reference_o2_conv) / (reference_o2_conv * dk)
#             sens13.append(Sens13)
#
#             Sens8 = (new_full_oxidation_selectivity - reference_full_oxidation_selectivity) / (
#                         reference_full_oxidation_selectivity * dk)
#             sens8.append(Sens8)
#
#             Sens9 = (new_full_oxidation_yield - reference_full_oxidation_yield) / (reference_full_oxidation_yield * dk)
#             sens9.append(Sens9)
#
#             new_exit_temp = T_array[-1]  # Sensitivity definition 10: exit temperature
#             Sens10 = (new_exit_temp - reference_exit_temp) / (reference_exit_temp * dk)
#             sens10.append(Sens10)
#
#             new_peak_temp = max(T_array)  # Sensitivity definition 11: peak temperature
#             Sens11 = (new_peak_temp - reference_peak_temp) / (reference_peak_temp * dk)
#             sens11.append(Sens11)
#
#             new_peak_temp_dist = dist_array[
#                 T_array.index(max(T_array))]  # Sensitivity definition 12: dist to peak temperature
#             Sens12 = (new_peak_temp_dist - reference_peak_temp_dist) / (reference_peak_temp_dist * dk)
#             sens12.append(Sens12)
#
#             print "%d %s %.3F %.3F" % (m, surf.species_name(m), Sens1, Sens2)
#             rxns.append(surf.species_name(m))
#
#             # this step is essential, otherwise mechanism will have been altered
#             s.thermo = ct.NasaPoly2(100.000, 5000.000, ct.one_atm, original_coeffs)
#             surf.modify_species(m, s)
#     else:  # reaction sensitivity analysis, the DEFAULT
#         for rxn in range(surf.n_reactions):
#             c = monolithFull(gas, surf, temp, moles_in, sens=[dk, rxn])
#             gas_out, surf_out, gas_names, surf_names, dist_array, T_array = c  # unpack
#
#             new_amts = []
#             for a in range(len(gas_names)):
#                 new_amts.append([gas_names[a], [gas_out[:, a]]])
#
#             for x in new_amts:
#                 if x[0] == 'CH4(2)':
#                     new_ch4_in = x[1][0][0]
#                     new_ch4_out = x[1][0][-1]
#                     if new_ch4_out < 0:
#                         new_ch4_out = 0.
#                     new_ch4_depletion = new_ch4_in - new_ch4_out
#                     if new_ch4_depletion <= 1e-8:
#                         new_ch4_depletion = 1e-8
#                         new_ch4_conv = 1e-8
#                     else:
#                         new_ch4_conv = new_ch4_depletion / new_ch4_in  # Sensitivity definition 7: CH4 conversion
#                 if x[0] == 'Ar':
#                     ar = x[1][0][-1]
#                 if x[0] == 'O2(3)':
#                     new_o2_in = x[1][0][0]
#                     new_o2_out = x[1][0][-1]
#                     if new_o2_out < 0:
#                         new_o2_out = 0.
#                     elif new_o2_out > new_o2_in:
#                         new_o2_out = new_o2_in
#                     new_o2_depletion = new_o2_in - new_o2_out
#                     if new_o2_depletion <= 1.0e-8:
#                         new_o2_depletion = 1.0e-8
#                         new_o2_conv = 1.0e-8
#                     else:
#                         new_o2_conv = new_o2_depletion / new_o2_in
#                 if x[0] == 'CO(7)':
#                     new_co_out = x[1][0][-1]
#                 if x[0] == 'H2(6)':
#                     new_h2_out = x[1][0][-1]
#                 if x[0] == 'H2O(5)':
#                     new_h2o_out = x[1][0][-1]
#                 if x[0] == 'CO2(4)':
#                     new_co2_out = x[1][0][-1]
#
#             if new_ch4_conv <= 1e-8:  # if basically nothing happens, sub in close to zeros so there are no divide by zero errors
#                 new_h2_sel = 1.0e-8
#                 new_co_sel = 1.0e-8
#                 new_syngas_selectivity = 1.0e-8
#                 new_syngas_yield = 1.0e-8
#                 new_co_yield = 1.0e-8
#                 new_h2_yield = 1.0e-8
#                 new_full_oxidation_selectivity = 1.0e-8
#                 new_full_oxidation_yield = 1.0e-8
#                 new_o2_conv = 1.0e-8
#             else:
#                 new_h2_sel = new_h2_out / (new_ch4_depletion * 2)  # Sensitivity definition 5: H2 selectivity
#                 new_co_sel = new_co_out / new_ch4_depletion  # Sensitivity definition 3: CO selectivity
#                 new_syngas_selectivity = new_co_sel + new_h2_sel  # Sensitivity definition 1: SYNGAS selectivity
#                 new_syngas_yield = new_syngas_selectivity * new_ch4_conv  # Sensitivity definition 2: SYNGAS yield
#                 new_co_yield = new_co_out / new_ch4_in  # Sensitivity definition 4: CO % yield
#                 new_h2_yield = new_h2_out / (2 * new_ch4_in)  # Sensitivity definition 6: H2 % yield
#                 new_h2o_sel = new_h2o_out / (new_ch4_depletion * 2)  # Sensitivity definition 8: H2O + CO2 selectivity
#                 new_co2_sel = new_co2_out / new_ch4_depletion
#                 new_full_oxidation_selectivity = new_h2o_sel + new_co2_sel
#                 new_full_oxidation_yield = new_full_oxidation_selectivity * new_ch4_conv  # Sensitivity definition 9: C2O + CO2 yield
#
#             Sens5 = (new_h2_sel - reference_h2_sel) / (reference_h2_sel * dk)
#             sens5.append(Sens5)
#
#             Sens3 = (new_co_sel - reference_co_sel) / (reference_co_sel * dk)
#             sens3.append(Sens3)
#
#             Sens1 = (new_syngas_selectivity - reference_syngas_selectivity) / (reference_syngas_selectivity * dk)
#             sens1.append(Sens1)
#
#             Sens2 = (new_syngas_yield - reference_syngas_yield) / (reference_syngas_yield * dk)
#             sens2.append(Sens2)
#
#             Sens4 = (new_co_yield - reference_co_yield) / (reference_co_yield * dk)
#             sens4.append(Sens4)
#
#             Sens6 = (new_h2_yield - reference_h2_yield) / (reference_h2_yield * dk)
#             sens6.append(Sens6)
#
#             Sens7 = (new_ch4_conv - reference_ch4_conv) / (
#                     reference_ch4_conv * dk)
#             sens7.append(Sens7)
#
#             Sens13 = (new_o2_conv - reference_o2_conv) / (reference_o2_conv * dk)
#             sens13.append(Sens13)
#
#             Sens8 = (new_full_oxidation_selectivity - reference_full_oxidation_selectivity) / (
#                     reference_full_oxidation_selectivity * dk)
#             sens8.append(Sens8)
#
#             Sens9 = (new_full_oxidation_yield - reference_full_oxidation_yield) / (reference_full_oxidation_yield * dk)
#             sens9.append(Sens9)
#
#             new_exit_temp = T_array[-1]  # Sensitivity definition 10: exit temperature
#             Sens10 = (new_exit_temp - reference_exit_temp) / (reference_exit_temp * dk)
#             sens10.append(Sens10)
#
#             new_peak_temp = max(T_array)  # Sensitivity definition 11: peak temperature
#             Sens11 = (new_peak_temp - reference_peak_temp) / (reference_peak_temp * dk)
#             sens11.append(Sens11)
#
#             new_peak_temp_dist = dist_array[T_array.index(max(T_array))]  # Sensitivity definition 12: dist to peak temperature
#             Sens12 = (new_peak_temp_dist - reference_peak_temp_dist) / (reference_peak_temp_dist * dk)
#             sens12.append(Sens12)
#
#             print "%d %s %.3F %.3F" % (rxn, surf.reaction_equations()[rxn], Sens1, Sens2)
#             rxns.append(surf.reaction_equations()[rxn])
#
#     return rxns, sens1, sens2, sens3, sens4, sens5, sens6, sens7, sens8, sens9, sens10, sens11, sens12, sens13
#
#
# def export(rxns_translated, ratio, thermo=False):  # export all of the sensitivity simulations to a csv
#     k = (pd.DataFrame.from_dict(data=rxns_translated, orient='columns'))
#     k.columns = ['Reaction', 'SYNGAS Selec', 'SYNGAS Yield', 'CO Selectivity', 'CO % Yield', 'H2 Selectivity', 'H2 % Yield',
#                  'CH4 Conversion', 'H2O+CO2 Selectivity', 'H2O+CO2 yield', 'Exit Temp', 'Peak Temp',
#                  'Dist to peak temp', 'O2 Conversion']
#     out_dir = 'sensitivities'
#     os.path.exists(out_dir) or os.makedirs(out_dir)
#     if thermo is True:
#         k.to_csv(out_dir + '/{:.1f}ThermoSensitivity.csv'.format(ratio), header=True)
#     else:
#         k.to_csv(out_dir + '/{:.1f}RxnSensitivity.csv'.format(ratio), header=True)
#
#
# def sensitivityWorker(data):  # actually run all of the sensitivity simulations
#     print('Starting sensitivity simulation for a C/O ratio of {:.1f}'.format(data[0]))
#     old_data = data[1][0]
#     ratio = data[0]
#     try:
#         reactions, sensitivity1, sensitivity2, sensitivity3, sensitivity4, sensitivity5, sensitivity6, sensitivity7, sensitivity8, sensitivity9, sensitivity10, sensitivity11, sensitivity12, sensitivity13 = sensitivity(gas, surf, old_data, t_in, dk)
#         print('Finished sensitivity simulation for a C/O ratio of {:.1f}'.format(ratio))
#         rxns_translated = []
#         for x in reactions:  # translate reactions into smiles to make them easier to compare with eachother
#             for key, smile in names.iteritems():
#                 x = re.sub(re.escape(key), smile, x)
#             rxns_translated.append(x)
#         print('Finished translating for C/O ratio of {:.1f}'.format(ratio))
#         output = []
#         for x in range(len(rxns_translated)):
#             output.append([rxns_translated[x], sensitivity1[x], sensitivity2[x], sensitivity3[x], sensitivity4[x],
#                            sensitivity5[x], sensitivity6[x], sensitivity7[x], sensitivity8[x], sensitivity9[x],
#                            sensitivity10[x], sensitivity11[x], sensitivity12[x], sensitivity13[x]])
#         export(output, ratio)
#     except Exception, e: print str(e)
#         # print('Unable to run sensitivity simulation at a C/O ratio of {:.1f}'.format(data[0]))
#         # pass
#
#
# def sensitivityThermoWorker(data):  # sensitivity for thermo parameters
#     print('Starting thermo sensitivity simulation for a C/O ratio of {:.1f}'.format(data[0]))
#     old_data = data[1][0]
#     ratio = data[0]
#     try:
#         species_on_surface, sensitivity1, sensitivity2, sensitivity3, sensitivity4, sensitivity5, sensitivity6, sensitivity7, sensitivity8, sensitivity9, sensitivity10, sensitivity11, sensitivity12, sensitivity13 = sensitivity(gas, surf, old_data, t_in, dk, thermo=True)
#         print('Finished thermo sensitivity simulation for a C/O ratio of {:.1f}'.format(ratio))
#         species_translated = []
#         for x in species_on_surface:  # translating into smiles to make it easier to compare
#             for key, smile in names.iteritems():
#                 x = re.sub(re.escape(key), smile, x)
#             species_translated.append(x)
#         output = []
#         for x in range(len(species_on_surface)):
#             output.append([species_translated[x], sensitivity1[x], sensitivity2[x], sensitivity3[x], sensitivity4[x],
#                            sensitivity5[x], sensitivity6[x], sensitivity7[x], sensitivity8[x], sensitivity9[x],
#                            sensitivity10[x], sensitivity11[x], sensitivity12[x], sensitivity13[x]])
#         export(output, ratio, thermo=True)
#     except Exception, e: print str(e)
#         # print('Unable to run thermo sensitivity simulation at a C/O ratio of {:.1f}'.format(data[0]))
#         # pass
#
#
# species_dict = rmgpy.data.kinetics.KineticsLibrary().getSpecies('species_dictionary.txt')  # import the species dictionary
# keys = species_dict.keys()
# # get the first listed smiles string for each molecule
# smile = []
# for s in species_dict:
#     smile.append(species_dict[s].molecule[0])
#     if len(species_dict[s].molecule) is not 1:
#         print 'There are %d dupllicate smiles for %s:' % (len(species_dict[s].molecule), s)
#         for a in range(len(species_dict[s].molecule)):
#             print '%s' % (species_dict[s].molecule[a])
# # translate the molecules from above into just smiles strings
# smiles = []
# for s in smile:
#     smiles.append(s.toSMILES())
# names = dict(zip(keys, smiles))
#
# # actually run the reaction sensitivity analyses
# worker_input = []
# dk = 1.0e-2
# num_threads = len(data)
# pool = multiprocessing.Pool(processes=num_threads)
# worker_input = []
# for r in range(len(data)):
#     worker_input.append([data[r][0], [data[r][1]]])
# pool.map(sensitivityWorker, worker_input, 1)
# pool.close()
# pool.join()
#
#
# # actually run the thermo sensitivity analyses
# worker_input = []
# sens_thermo = []
# dk = 1.0e-2
# num_threads = len(data)
# pool = multiprocessing.Pool(processes=num_threads)
# for r in range(len(data)):
#     worker_input.append([data[r][0], [data[r][1]]])
# pool.map(sensitivityThermoWorker, worker_input, 1)
