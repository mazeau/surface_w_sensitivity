"""
This example is from doi:10.1016/j.jcat.2007.05.011, Horn 2007
Ref 17 is doi:10.1016/j.cat.2006.05.008
Ref 18 is doi:10.1007/s10562-006-0117-8

surface to reactor volume ratio (assuming same active catalytic area) A/V, at 1600.0 m-1, from Ref 17
assume catalyst is a monolith, at 16.5 mm in diam, from Ref 17 & Ref 18
porosity is 0.81, from Ref 17
front heat sheild, cataylst, and back heat sheild is 10 mm long, from Ref 17
inlet mol flow at 0.208 mol/min

graphs are in:
exit conversion % v c/0 ratio
flow/mol/min v position(mm)
S at end oxidation zone/ % v C/O ratio
selectivity S, yield(Y)/% v C/O ratio
flow/ mol/min v position (z)/ mm

also had plots with flow/ mol/ min v C/O ratio w lines of thermodynamic equilibrium )ph = const)
"""
# load a bunch of stuff
import cantera as ct
import numpy as np
import scipy
import pylab
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from matplotlib.pyplot import cm
from matplotlib.ticker import NullFormatter, MaxNLocator, LogLocator
plt.switch_backend('agg')  # needed for saving figures
import csv
from pydas.dassl import DASSL
import os
import rmgpy
import rmg
import re
import operator
import pandas as pd
import pylab
from cycler import cycler
import seaborn as sns
import os
import multiprocessing

# this chemkin file is from the cti generated by rmg
gas = ct.Solution('./chem_annotated.cti', 'gas')
surf = ct.Interface('./chem_annotated.cti', 'surface1', [gas])

print("This mechanism contains {} gas reactions and {} surface reactions".format(gas.n_reactions, surf.n_reactions))

i_ar = gas.species_index('Ar')
i_ch4 = gas.species_index('CH4(2)')
i_o2 = gas.species_index('O2(3)')
i_co2 = gas.species_index('CO2(4)')
i_h2o = gas.species_index('H2O(5)')
i_h2 = gas.species_index('H2(6)')
i_co = gas.species_index('CO(7)')

# unit conversion factors to SI
mm = 0.001
cm = 0.01
ms = mm
minute = 60.0

#######################################################################
# Input Parameters
#######################################################################
t_in = 700  # K - in the paper, it was ~698.15K at the start of the cat surface and ~373.15 for the gas inlet temp
t_cat = t_in
length = 70 * mm  # Reactor length- m, as seen in doi:10.1016/j.jcat.2007.05.011, Horn 2007
diam = 16.5*mm  # Reactor diameter - in m, as seen in doi:10.1016/j.jcat.2007.05.011, Horn 2007
area = (diam/2.0)**2*np.pi  # Reactor cross section area (area of tube) in m^2, as seen in doi:10.1016/j.jcat.2007.05.011, Horn 2007
porosity = 0.81  # Monolith channel porosity, from Horn ref 17 sec 2.2.2
# todo: re-run with this cat_area_per_vol value, because previously used 10000 m2/m3.
#       4500 is lowest that "work" for all base.
cat_area_per_vol = 16000  # m2/m3, which is 160 cm2/cm3, as used in Horn 2006
flow_rate = 4.7  # slpm, as seen in as seen in doi:10.1016/j.jcat.2007.05.011, Horn 2007
flow_rate = flow_rate*.001/60  # m^3/s, as seen in as seen in doi:10.1016/j.jcat.2007.05.011, Horn 2007
tot_flow = 0.208  # from Horn 2007, constant inlet flow rate in mol/min, equivalent to 4.7 slpm
velocity = flow_rate/area  # m/s, by inspection

# The PFR will be simulated by a chain of 'NReactors' stirred reactors.
NReactors = 7001

on_catalyst = 1000  # catalyst length 10mm, but it doesn't say where.  starts at 1 cm
off_catalyst = 2000  # catalyst ends at 2 cm (lasts 20 mm)
dt = 1.0

reactor_len = length/(NReactors-1)  # find the length of each individual reactor, not including the last one
rvol = area * reactor_len * porosity  # each reactor's volume

# catalyst area in one reactor
cat_area = cat_area_per_vol * rvol  # the amount of catalyst per reactor volume

def plotflow(a):
    """
    Given the output of a simulation, plot the species profiles through the PFR
    """
    gas_out, surf_out, gas_names, surf_names, dist_array, T_array = a

    # Plot in mol/min
    fig, axs = plt.subplots(1, 2)  # two plots

    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    for i in range(len(gas_out[0, :])):
        if i != i_ar:
            if gas_out[:, i].max() > 5.e-3:
                #             print(gas_names[i])
                axs[0].plot(dist_array, gas_out[:, i], label=gas_names[i])
                species_name = gas_names[i]
                if species_name.endswith(')'):
                    if species_name[-3] == '(':
                        species_name = species_name[0:-3]
                    else:
                        species_name = species_name[0:-4]
                if species_name == "O2":
                    axs[0].annotate("O$_2$", fontsize=14, color='y',
                                    xy=(dist_array[500], gas_out[:, i][500] + gas_out[:, i][500] / 100.0),
                                    va='bottom', ha='center')
                elif species_name == "CO2":
                    axs[0].annotate("CO$_2$", fontsize=14, color='c',
                                    xy=(dist_array[2300], gas_out[:, i][5000] + gas_out[:, i][5000] / 10.0), va='bottom',
                                    ha='center')
                elif species_name == "CO":
                    axs[0].annotate("CO", fontsize=14, color='g', xy=(dist_array[6000], gas_out[:, i][6000] + 0.001),
                                    va='bottom', ha='center')
                elif species_name == "H2":
                    axs[0].annotate("H$_2$", fontsize=14, color='k', xy=(dist_array[6000], gas_out[:, i][6000] - 0.001),
                                    va='top', ha='center')
                elif species_name == "CH4":
                    axs[0].annotate("CH$_4$", fontsize=14, color='b',
                                    xy=(dist_array[500], gas_out[:, i][500] + gas_out[:, i][500] / 100.0),
                                    va='bottom', ha='center')
                elif species_name == "H2O":
                    axs[0].annotate("H$_2$O", fontsize=14, color='r',
                                    xy=(dist_array[5000], gas_out[:, i][5000] + gas_out[:, i][5000] / 40.0 + 0.001), va='bottom',
                                    ha='center')
                else:
                    axs[0].annotate(species_name, fontsize=14,
                                    xy=(dist_array[-1], gas_out[:, i][-1] + gas_out[:, i][-1] / 10.0), va='top',
                                    ha='center')
            else:
                axs[0].plot(0, 0)

    axs[1].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))
    axs[1].plot(dist_array, T_array, label="surface + gas reactions")

    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    axs[0].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [0, 0.3], linestyle='--', color='xkcd:grey')
    axs[0].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [0, 0.3], linestyle='--', color='xkcd:grey')
    axs[0].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 0.275), va='bottom', ha='left')
    axs[1].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [400.0, 2500], linestyle='--', color='xkcd:grey')
    axs[1].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [400.0, 2500], linestyle='--', color='xkcd:grey')
    axs[1].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 500), va='bottom', ha='left')

    for item in (
            axs[0].get_xticklabels() + axs[0].get_yticklabels() + axs[1].get_xticklabels() + axs[1].get_yticklabels()):
        item.set_fontsize(12)

    axs[1].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=2)
    axs[0].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=4)
    axs[0].set_ylim(0., 0.15)
    axs[1].set_ylim(400.0, 2400)
    axs[0].set_xlim(0.0, length / mm)
    axs[1].set_xlim(0.0, length / mm)
    axs[0].set_xlabel('Distance (mm)', fontsize=13)
    axs[1].set_xlabel('Distance (mm)', fontsize=13)  # axs[0,1].set_xlabel('time (s)'); axs[1,1].set_xlabel('time (s)')
    axs[0].set_ylabel('flow/ mol/min', fontsize=13)
    axs[1].set_ylabel('Temperature (K)', fontsize=13)
    fig.set_figheight(6)
    fig.set_figwidth(18)

    # getting the input gas ratios
    for n in range(len(gas_names)):
        if gas_names[n] == 'CH4(2)':
            c_in = gas_out[0][n]
        if gas_names[n] == 'O2(3)':
            o_in = gas_out[0][n]
    ratio = round(c_in / (o_in * 2), 1)

    out_dir = 'figures'
    os.path.exists(out_dir) or os.makedirs(out_dir)
    fig.savefig(out_dir + '/' + str(ratio) + 'ratio.pdf', bbox_inches='tight')


def plotZoom(a):
    """
    A zoomed in version of plotFlow, takes all the same inputs
    """
    gas_out, surf_out, gas_names, surf_names, dist_array, T_array = a

    fig, axs = plt.subplots(1, 2)
    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    for i in range(len(gas_out[0, :])):
        if i != i_ar:
            if gas_out[:, i].max() > 5.e-3:
                #             print(gas_names[i])
                axs[0].plot(dist_array, gas_out[:, i], label=gas_names[i])
                species_name = gas_names[i]
                if species_name.endswith(')'):
                    if species_name[-3] == '(':
                        species_name = species_name[0:-3]
                    else:
                        species_name = species_name[0:-4]
                if species_name == "O2":
                    axs[0].annotate("O$_2$", fontsize=14, color='y',
                                    xy=(dist_array[1100], gas_out[:, i][1100] + gas_out[:, i][1100] / 100.0),
                                    va='bottom', ha='center')
                elif species_name == "CO2":
                    axs[0].annotate("CO$_2$", fontsize=14, color='c',
                                    xy=(dist_array[2400], gas_out[:, i][2400] + gas_out[:, i][2400] / 10.0), va='bottom',
                                    ha='center')
                elif species_name == "CO":
                    axs[0].annotate("CO", fontsize=14, color='g', xy=(dist_array[2100], gas_out[:, i][2100] + 0.001),
                                    va='bottom', ha='center')
                elif species_name == "H2":
                    axs[0].annotate("H$_2$", fontsize=14, color='k', xy=(dist_array[2200], gas_out[:, i][2200] - 0.001),
                                    va='top', ha='center')
                elif species_name == "CH4":
                    axs[0].annotate("CH$_4$", fontsize=14, color='b',
                                    xy=(dist_array[1100], gas_out[:, i][1100] + gas_out[:, i][1100] / 100.0),
                                    va='bottom', ha='center')
                elif species_name == "H2O":
                    axs[0].annotate("H$_2$O", fontsize=14, color='r',
                                    xy=(dist_array[2100], gas_out[:, i][2100] + gas_out[:, i][2100] / 40.0 + 0.001), va='bottom',
                                    ha='center')
                else:
                    axs[0].annotate(species_name, fontsize=14,
                                    xy=(dist_array[-1], gas_out[:, i][-1] + gas_out[:, i][-1] / 10.0), va='top',
                                    ha='center')
            else:
                axs[0].plot(0, 0)

    axs[1].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))
    # Plot two temperatures (of gas-phase and surface vs only surface.)
    # axs[1].plot(dist_array, T_array, label="temperature")
    ax2 = axs[0].twinx()
    ax2.plot(dist_array, T_array, label='temperature', color='r', linestyle=':')
    #     axs[1].plot(dist_array, T2_array, "--", label="surface reactions only")
    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    axs[0].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [0, 0.2], linestyle='--', color='xkcd:grey')
    axs[0].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [0, 0.2], linestyle='--', color='xkcd:grey')
    axs[0].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 0.175), va='bottom', ha='left')
    axs[1].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [600.0, 2000], linestyle='--', color='xkcd:grey')
    axs[1].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [600.0, 2000], linestyle='--', color='xkcd:grey')
    axs[1].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 1800), va='bottom', ha='left')

    for item in (
            axs[0].get_xticklabels() + axs[0].get_yticklabels() + ax2.get_xticklabels() + ax2.get_yticklabels()):
        item.set_fontsize(18)

    #axs[1].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=2)
    axs[0].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=4)
    axs[0].set_ylim(0., 0.1)
    axs[1].set_ylim(600.0, 2000)
    axs[0].set_xlim(8, 25)
    axs[1].set_xlim(8, 25)
    axs[0].set_xlabel('Distance (mm)', fontsize=20)
    axs[1].set_xlabel('Distance (mm)', fontsize=20)  # axs[0,1].set_xlabel('time (s)'); axs[1,1].set_xlabel('time (s)')
    axs[0].set_ylabel('flow/ mol/min', fontsize=20)
    # axs[1].set_ylabel('Temperature (K)', fontsize=20)
    ax2.set_ylabel('Temperature (K)', fontsize=20)
    ax2.set_ylim(600, 2000)
    ax2.set_xlim(8, 25)
    fig.set_figheight(6)
    fig.set_figwidth(24)

    for n in range(len(gas_names)):
        if gas_names[n] == 'CH4(2)':
            c_in = gas_out[0][n]
        if gas_names[n] == 'O2(3)':
            o_in = gas_out[0][n]
    ratio = c_in / (o_in * 2)
    ratio = round(ratio, 1)

    out_dir = 'figures'
    os.path.exists(out_dir) or os.makedirs(out_dir)
    fig.savefig(out_dir + '/' + str(ratio) + 'ratioZoom.pdf', bbox_inches='tight')


def plotSurf(a):
    """
    Plot the surface species' profiles throughout the PFR
    """
    gas_out, surf_out, gas_names, surf_names, dist_array, T_array = a

    fig, axs = plt.subplots(1, 2)
    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    for i in range(len(gas_out[0, :])):
        if i != i_ar:
            if gas_out[:, i].max() > 5.e-3:
                #             print(gas_names[i])
                axs[0].plot(dist_array, gas_out[:, i], label=gas_names[i])
                species_name = gas_names[i]
                if species_name.endswith(')'):
                    if species_name[-3] == '(':
                        species_name = species_name[0:-3]
                    else:
                        species_name = species_name[0:-4]
                if species_name == "O2":
                    axs[0].annotate("O$_2$", fontsize=12,
                                    xy=(dist_array[2200], gas_out[:, i][2200] + gas_out[:, i][2200] / 100.0),
                                    va='bottom', ha='center')
                elif species_name == "CO2":
                    axs[0].annotate("CO$_2$", fontsize=12,
                                    xy=(dist_array[2200], gas_out[:, i][2200] + gas_out[:, i][2200] / 10.0), va='top',
                                    ha='center')
                elif species_name == "CO":
                    axs[0].annotate("CO", fontsize=12, xy=(dist_array[2200], gas_out[:, i][2200] + 0.001),
                                    va='bottom', ha='center')
                elif species_name == "CH2O":
                    axs[0].annotate("CH$_2$O", fontsize=12, xy=(dist_array[2200], gas_out[:, i][2200] + 0.001),
                                    va='bottom', ha='center')
                elif species_name == "CH4":
                    axs[0].annotate("CH$_4$", fontsize=12,
                                    xy=(dist_array[2200], gas_out[:, i][2200] + gas_out[:, i][2200] / 100.0),
                                    va='bottom', ha='center')
                elif species_name == "H2O":
                    axs[0].annotate("H$_2$O", fontsize=12,
                                    xy=(dist_array[2200], gas_out[:, i][2200] + gas_out[:, i][2200] / 40.0), va='top',
                                    ha='center')
                else:
                    axs[0].annotate(species_name, fontsize=12,
                                    xy=(dist_array[-1], gas_out[:, i][-1] + gas_out[:, i][-1] / 10.0), va='top',
                                    ha='center')
            else:
                axs[0].plot(0, 0)

    axs[1].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))
    # Plot two temperatures (of gas-phase and surface vs only surface.)
    for i in range(len(surf_out[0, :])):
        if surf_out[:, i].max() > 5.e-3:
            axs[1].plot(dist_array, surf_out[:, i], label=surf_names[i])
    axs[0].set_prop_cycle(cycler('color', ['m', 'g', 'b', 'y', 'c', 'r', 'k', 'g']))

    axs[0].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [0, 0.2], linestyle='--', color='xkcd:grey')
    axs[0].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [0, 0.2], linestyle='--', color='xkcd:grey')
    axs[0].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 0.175), va='bottom', ha='left')
    axs[1].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [0, 1.2], linestyle='--', color='xkcd:grey')
    axs[1].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [0, 1.2], linestyle='--', color='xkcd:grey')
    axs[1].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 1.1), va='bottom', ha='left')

    for item in (
            axs[0].get_xticklabels() + axs[0].get_yticklabels() + axs[1].get_xticklabels() + axs[1].get_yticklabels()):
        item.set_fontsize(12)

    axs[1].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=2)
    axs[0].legend(loc='upper center', bbox_to_anchor=(0.5, -0.2), fancybox=False, shadow=False, ncol=4)
    axs[0].set_ylim(0., 0.1)
    axs[1].set_ylim(0, 1.2)
    axs[0].set_xlim(5, 25)
    axs[1].set_xlim(5, 25)
    axs[0].set_xlabel('Distance (mm)', fontsize=13)
    axs[1].set_xlabel('Distance (mm)', fontsize=13)  # axs[0,1].set_xlabel('time (s)'); axs[1,1].set_xlabel('time (s)')
    axs[0].set_ylabel('flow/ mol/min', fontsize=13)
    axs[1].set_ylabel('Site fraction', fontsize=13)
    # fig.tight_layout()
    # axs[1,0].ticklabel_format(axis='x', style='sci', scilimits=(0,0))
    # axs[0,1].ticklabel_format(axis='x', style='sci', scilimits=(0,0))
    # axs[1,1].ticklabel_format(axis='x', style='sci', scilimits=(0,0))
    fig.set_figheight(6)
    fig.set_figwidth(18)

    #     temperature = np.round(T_array[0],0)
    for n in range(len(gas_names)):
        if gas_names[n] == 'CH4(2)':
            c_in = gas_out[0][n]
        if gas_names[n] == 'O2(3)':
            o_in = gas_out[0][n]
    ratio = c_in / (o_in * 2)
    ratio = round(ratio, 1)

    out_dir = 'figures'
    os.path.exists(out_dir) or os.makedirs(out_dir)
    fig.savefig(out_dir + '/' + str(ratio) + 'surf.pdf', bbox_inches='tight')

def monolithFull(gas, surf, temp, mol_in, verbose=False, sens=False):
    """
    Verbose prints out values as you go along
    Sens is for sensitivity, in the form [perturbation, reaction #]
    
    This runs each individual simulation
    """
    ch4, o2, ar = mol_in  # unpacking the starting gas ratios
    ratio = ch4/(2*o2)
    ratio = round(ratio, 1)
    ch4 = str(ch4)
    o2 = str(o2)
    ar = str(ar)
    X = str('CH4(2):' + ch4 + ', O2(3):' + o2 + ', Ar:' + ar)
    gas.TPX = 273.15, ct.one_atm, X  # need to initialize mass flow rate at STP
    # mass_flow_rate = velocity * gas.density_mass * area  # kg/s
    mass_flow_rate = flow_rate * gas.density_mass
    gas.TPX = temp, ct.one_atm, X
    temp_cat = temp
    surf.TP = temp_cat, ct.one_atm
    surf.coverages = 'X(1):1.0'
    gas.set_multiplier(1.0)

    TDY = gas.TDY
    cov = surf.coverages

    if verbose is True:  # setting up how things will print out if it is wanted
        print('  distance(mm)   X_CH4        X_O2        X_H2       X_CO       X_H2O       X_CO2')

    # create a new reactor
    gas.TDY = TDY
    r = ct.IdealGasReactor(gas)
    r.volume = rvol

    # create a reservoir to represent the reactor immediately upstream. Note
    # that the gas object is set already to the state of the upstream reactor
    upstream = ct.Reservoir(gas, name='upstream')

    # create a reservoir for the reactor to exhaust into. The composition of
    # this reservoir is irrelevant.
    downstream = ct.Reservoir(gas, name='downstream')

    # Add the reacting surface to the reactor. The area is set to the desired
    # catalyst area in the reactor.
    rsurf = ct.ReactorSurface(surf, r, A=cat_area)

    # The mass flow rate into the reactor will be fixed by using a
    # MassFlowController object.
    # mass_flow_rate = velocity * gas.density_mass * area  # kg/s
    # mass_flow_rate = flow_rate * gas.density_mass
    m = ct.MassFlowController(upstream, r, mdot=mass_flow_rate)

    # We need an outlet to the downstream reservoir. This will determine the
    # pressure in the reactor. The value of K will only affect the transient
    # pressure difference.
    v = ct.PressureController(r, downstream, master=m, K=1e-5)

    sim = ct.ReactorNet([r])
    sim.max_err_test_fails = 12

    # set relative and absolute tolerances on the simulation
    # these vary on the type of computer used and are super annoying so good luck
    sim.rtol = 1.0e-10
    sim.atol = 1.0e-20

    gas_names = gas.species_names  # save the gas species names
    surf_names = surf.species_names  # save the surface species' names
    gas_out = []  # save the gas species concentrations
    
    # arrays to store the useful information in
    surf_out = []
    dist_array = []
    T_array = []

    surf.set_multiplier(0.0)  # no surface reactions until the gauze/catalyst
    for n in range(NReactors):
        # Set the state of the reservoir to match that of the previous reactor
        gas.TDY = r.thermo.TDY
        upstream.syncState()
        if n == on_catalyst:  # turn the catalyst `on'
            surf.set_multiplier(1.0)
            if sens is not False:
                surf.set_multiplier(1.0 + sens[0], sens[1])
        if n == off_catalyst:  # turn the catalyst `off'
            surf.set_multiplier(0.0)
        sim.reinitialize()
        sim.advance_to_steady_state()
        dist = n * reactor_len * 1.0e3  # distance in mm
        dist_array.append(dist)
        T_array.append(surf.T)
        kmole_flow_rate = mass_flow_rate / gas.mean_molecular_weight  # kmol/s
        gas_out.append(1000 * 60 * kmole_flow_rate * gas.X.copy())  # molar flow rate in moles/minute
        surf_out.append(surf.X.copy())

        # make reaction diagrams
#         out_dir = 'rxnpath'
#         os.path.exists(out_dir) or os.makedirs(out_dir)
#         elements = ['H', 'O']
#         locations_of_interest = [1000, 1200, 1400, 1600, 1800, 1999]
        # if sens is False:
        #     for l in locations_of_interest:
        #         if n == l:
        #             location = str(int(n / 100))
        #
        #             diagram = ct.ReactionPathDiagram(surf, 'X')
        #             diagram.title = 'rxn path'
        #             diagram.label_threshold = 1e-9
        #             dot_file = out_dir + '/rxnpath-' + str(ratio) + '-x-' + location + 'mm.dot'
        #             img_file = out_dir + '/rxnpath-' + str(ratio) + '-x-' + location + 'mm.png'
        #             img_path = os.path.join(out_dir, img_file)
        #             diagram.write_dot(dot_file)
        #             os.system('dot {0} -Tpng -o{1} -Gdpi=200'.format(dot_file, img_file))
        #
        #             for element in elements:
        #                 diagram = ct.ReactionPathDiagram(surf, element)
        #                 diagram.title = element + 'rxn path'
        #                 diagram.label_threshold = 1e-9
        #                 dot_file = out_dir + '/rxnpath-' + str(ratio) + '-surf-' + location + 'mm-' + element + '.dot'
        #                 img_file = out_dir + '/rxnpath-' + str(ratio) + '-surf-' + location + 'mm-' + element + '.png'
        #                 img_path = os.path.join(out_dir, img_file)
        #                 diagram.write_dot(dot_file)
        #                 os.system('dot {0} -Tpng -o{1} -Gdpi=200'.format(dot_file, img_file))
        # else:
        #     pass

        if verbose is True:  # print out gas profiles at certain times if the user so desires
            if not n % 100:
                print('  {0:10f}  {1:10f}  {2:10f}  {3:10f} {4:10f} {5:10f} {6:10f}'.format(dist, *gas[
                    'CH4(2)', 'O2(3)', 'H2(6)', 'CO(7)', 'H2O(5)', 'CO2(4)'].X * 1000 * 60 * kmole_flow_rate))
    
    # save the things at the end or each reactor
    gas_out = np.array(gas_out)
    surf_out = np.array(surf_out)
    gas_names = np.array(gas_names)
    surf_names = np.array(surf_names)
    data_out = gas_out, surf_out, gas_names, surf_names, dist_array, T_array
    return data_out


def simulationWorker(ratio):
    """
    Start all of the simulations all at once using multiprocessing
    """
    fo2 = 1 / (2. * ratio + 1 + 79 / 21)
    fch4 = 2 * fo2 * ratio
    far = 79 * fo2 / 21
    ratio_in = [fch4, fo2, far]  # mol fractions

    try:  # make a try loop because of CVODES errors
        a = monolithFull(gas, surf, t_in, ratio_in)
        print("Finished simulation at a C/O ratio of {:.1f}".format(ratio))
        gas_out, surf_out, gas_names, surf_names, dist_array, T_array = a
        plotflow(a)
        plotZoom(a)
        plotSurf(a)
        return [ratio, [gas_out, gas_names, dist_array, T_array]]
    except:
        print('Unable to run simulation at a C/O ratio of {:.1f}'.format(ratio))
        pass


ratios = [.6, .7, .8, .9, 1., 1.1, 1.2, 1.3, 1.4, 1.6, 1.8, 2., 2.2, 2.4, 2.6]  # 15 items
data = []
num_threads = len(ratios)
pool = multiprocessing.Pool(processes=num_threads)
data = pool.map(simulationWorker, ratios, 1)  # start the simulations in parallel
pool.close()
pool.join()

# finding exit conversions
# this is a horrible, inefficient way to do this but it works for now.  Let's hope I fix it before this code is published
end_temp = []
max_temp = []
dist_max_temp = []
ch4_in = []
ch4_out = []
ch4_conv = []
o2_conv = []
co_sel = []
co_out = []
h2_sel = []
h2_out = []
h2o_sel = []
h2o_out = []
co2_sel = []
co2_out = []
ratios_real = []
for r in data:
    # gas_out,gas_names,dist_array,T_array = r[1]
    for x in range(len(r[1][1])):
        if r[1][1][x] == 'CH4(2)':
            ch4_i = r[1][0][0][x]
            ch4_in.append(ch4_i)
            ch4_o = r[1][0][-1][x]
            if ch4_o < 0:
                ch4_o = 0.
            ch4_out.append(ch4_o)
            ch4_depletion = ch4_i - ch4_o
            if ch4_depletion <= 0:
                ch4_depletion = 0.
            ch4_conv.append(ch4_depletion / ch4_i)
        if r[1][1][x] == 'O2(3)':
            o2_in = r[1][0][0][x]
            o2_out = r[1][0][-1][x]
            if o2_out < 0:
                o2_out = 0.
            elif o2_out > o2_in:
                o2_out = o2_in
            conv = (o2_in - o2_out) / o2_in
            if conv < 0:
                o2_conv.append(0.)
            else:
                o2_conv.append(conv)
    ratios_real.append(ch4_i / (2 * o2_in))
    end_temp.append(r[1][3][-1])
    max_temp.append(max(r[1][3]))
    dist_max_temp.append(r[1][2][r[1][3].index(max(r[1][3]))])

    for x in range(len(r[1][1])):
        if r[1][1][x] == 'Ar':
            ar = r[1][0][-1][x]
        if r[1][1][x] == 'CO(7)':
            co_o = r[1][0][-1][x]
            co_out.append(co_o)
            co_sel.append(co_o / ch4_depletion)
        if r[1][1][x] == 'H2O(5)':
            h2o_o = r[1][0][-1][x]
            h2o_out.append(h2o_o)
            h2o_sel.append(h2o_o / (ch4_depletion * 2))
        if r[1][1][x] == 'H2(6)':
            h2_o = r[1][0][-1][x]
            h2_out.append(h2_o)
            h2_sel.append(h2_o / (ch4_depletion * 2))
        if r[1][1][x] == 'CO2(4)':
            co2_o = r[1][0][-1][x]
            co2_out.append(co2_o)
            co2_sel.append(co2_o / ch4_depletion)

output = []
for x in range(len(ratios_real)):
    output.append([ratios_real[x], ch4_in[x], ch4_out[x], co_out[x], h2_out[x], h2o_out[x], co2_out[x], end_temp[x], max_temp[x], dist_max_temp[x], o2_conv[x]])
k = (pd.DataFrame.from_dict(data=output, orient='columns'))
k.columns = ['C/O ratio', 'CH4 in', 'CH4 out', 'CO out', 'H2 out', 'H2O out', 'CO2 out', 'Exit temp', 'Max temp', 'Dist to max temp', 'O2 conv']
k.to_csv('dict_conversions_selectivities.csv', header=True)  # export the original simulation results to a csv in case things go wrong

# plot the simulation results over different ratios
fig, axs = plt.subplots(1, 2)
# plot exit conversion and temp
axs[0].plot(ratios_real, ch4_conv, 'bo-', label='CH4', color='limegreen')
axs[0].plot(ratios_real, o2_conv, 'bo-', label='O2', color='blue')
ax2 = axs[0].twinx()
ax2.plot(ratios_real, end_temp, 'bo-', label='temp', color='orange')
ax2.set_ylim(600.0, 2000)
# plot exit selectivities
axs[1].plot(ratios_real, co_sel, 'bo-', label='CO', color='green')
axs[1].plot(ratios_real, h2_sel, 'bo-', label='H2', color='purple')
axs[1].plot(ratios_real, co2_sel, 'bo-', label='CO2', color='navy')
axs[1].plot(ratios_real, h2o_sel, 'bo-', label='H2O', color='dodgerblue')
axs[0].legend()
axs[1].legend()
axs[0].set_ylabel('Exit conversion (%)', fontsize=13)
ax2.set_ylabel('Exit temperature (K)', fontsize=13)
axs[0].set_xlabel('C/O Ratio', fontsize=13)
axs[1].set_xlabel('C/O Ratio', fontsize=13)
axs[1].set_ylabel('Exit selectivity (%)', fontsize=13)
plt.tight_layout()
fig.set_figheight(6)
fig.set_figwidth(16)
out_dir = 'figures'
os.path.exists(out_dir) or os.makedirs(out_dir)
fig.savefig(out_dir + '/' + 'conversion&selectivity.pdf', bbox_inches='tight')

# comparing all species profiles, all in one
temps = []
o2 = []
co = []
h2 = []
ratios = []
for r in data:
    gas_out, gas_names, dist_array, T_array = r[1]
    for x in range(len(r[1][1])):
        if r[1][1][x] == 'O2(3)':
            o2.append(r[1][0][:, x])
        if r[1][1][x] == 'CO(7)':
            co.append(r[1][0][:, x])
        if r[1][1][x] == 'H2(6)':
            h2.append(r[1][0][:, x])
    dist_array = r[1][2]
    temps.append(r[1][3])
    ratios.append(r[0])

sns.set_palette(sns.color_palette("hls", 15))
fig, axs = plt.subplots(3, 1)
# plot exit conversion and temp
for r in range(len(ratios)):
    axs[0].plot(dist_array, o2[r], label=ratios[r])
    axs[1].plot(dist_array, h2[r], label=ratios[r])
    axs[2].plot(dist_array, co[r], label=ratios[r])
ax2 = axs[0].twinx()
for r in range(len(ratios)):
    ax2.plot(dist_array, temps[r])
axs[0].plot([dist_array[on_catalyst], dist_array[on_catalyst]], [-0.02, 0.2], linestyle='--', color='xkcd:grey')
axs[0].plot([dist_array[off_catalyst], dist_array[off_catalyst]], [-0.02, 0.2], linestyle='--', color='xkcd:grey')
axs[0].annotate("catalyst", fontsize=13, xy=(dist_array[on_catalyst], 0.08), va='bottom', ha='left')
axs[0].legend(loc='center left')
axs[0].set_ylabel('O2 Flow (mol/mm)', fontsize=13)
ax2.set_ylabel('Temperature (K)', fontsize=13)
axs[0].set_xlabel('Position (mm)', fontsize=13)
axs[1].set_ylabel('H2 Flow (mol/min)', fontsize=13)
axs[2].set_ylabel('CO Flow (mol/min)', fontsize=13)
axs[1].set_xlabel('Position (mm)', fontsize=13)
axs[2].set_xlabel('Position (mm)', fontsize=13)
ax2.set_ylim(200, 2000)
axs[0].set_ylim(0, .1)
axs[0].set_xlim(5, 25)
axs[1].set_xlim(5, 25)
axs[2].set_xlim(5, 25)
fig.set_figheight(14)
fig.set_figwidth(8)
out_dir = 'figures'
os.path.exists(out_dir) or os.makedirs(out_dir)
fig.savefig(out_dir + '/' + 'flows.pdf', bbox_inches='tight')


###################
# SENSITIVITY
###################


def sensitivity(gas, surf, old_data, temp, dk, thermo=False):
    """
    Function to get sensitivity, but running additional simulations and comparing
    to the original simulation (data) to get a numberical value for sensitivity.

    old_data is an array with the original simulation output.

    Has multiple ways to calculate sensitivity.  You can use all at once, but was
    written so that the other ways could be commented out.  I apologize
    """
    rxns = []
    sens1 = []
    sens2 = []
    sens3 = []
    sens4 = []
    sens5 = []
    sens6 = []
    sens7 = []
    sens8 = []
    sens9 = []
    sens10 = []
    sens11 = []
    sens12 = []
    sens13 = []

    gas_out_data, gas_names_data, dist_array_data, T_array_data = old_data  # unpacking

    reference = []
    for a in range(len(gas_names_data)):
        reference.append([gas_names_data[a], [gas_out_data[:, a]]])

    # getting the ratio
    for x in reference:
        if x[0] == 'CH4(2)':
            ch4_in = x[1][0][0]
        if x[0] == 'O2(3)':
            o2_in = x[1][0][0]
        if x[0] == 'Ar':
            ar_in = x[1][0][0]
    ratio = ch4_in / (2 * o2_in)
    moles_in = [ch4_in, o2_in, ar_in]
    
    # calculating things from the original simulations
    for x in reference:
        if x[0] == 'CH4(2)':
            ch4_in = x[1][0][0]
            ch4_out = x[1][0][-1]
            if ch4_out < 0:
                ch4_out = 0.
            ch4_depletion = ch4_in - ch4_out
            if ch4_depletion <= 1.0e-8:
                ch4_depletion = 1.0e-8
                reference_ch4_conv = 1.0e-8
            else:
                reference_ch4_conv = ch4_depletion / ch4_in  # Sensitivity definition 7: CH4 conversion
        if x[0] == 'Ar':
            ar = x[1][0][-1]
        if x[0] == 'O2(3)':
            o2_in = x[1][0][0]
            o2_out = x[1][0][-1]
            if o2_out < 0:
                o2_out = 0.  # O2 can't be negative
            elif o2_out > o2_in:
                o2_out = o2_in  # O2 can't be created, to make it equal to O2 in
            o2_depletion = o2_in - o2_out
            if o2_depletion <= 1.0e-8:
                o2_depletion = 1.0e-8
                reference_o2_conv = 1.0e-8
            else:
                reference_o2_conv = o2_depletion / o2_in  # Sensitivity definition 13: O2 conversion
        if x[0] == 'CO(7)':
            co_out = x[1][0][-1]
        if x[0] == 'H2(6)':
            h2_out = x[1][0][-1]
        if x[0] == 'H2O(5)':
            h2o_out = x[1][0][-1]
        if x[0] == 'CO2(4)':
            co2_out = x[1][0][-1]
    
    # if things are to small to make a difference, make them basically zero but also not give a divide by zero error
    if reference_ch4_conv <= 1.0e-8:
        reference_h2_sel = 1.0e-8
        reference_co_sel = 1.0e-8
        reference_syngas_selectivity = 1.0e-8
        reference_syngas_yield = 1.0e-8
        reference_co_yield = 1.0e-8
        reference_h2_yield = 1.0e-8
        reference_full_oxidation_selectivity = 1.0e-8
        reference_full_oxidation_yield = 1.0e-8
        reference_o2_conv = 1.0e-8
    else:
        # negative sensitivity is higher selectivity
        reference_h2_sel = h2_out / (ch4_depletion * 2)  # Sensitivity definition 5: H2 selectivity
        if reference_h2_sel <= 0:
            reference_h2_sel = 1.0e-15  # selectivity can't be 0

        reference_co_sel = co_out / ch4_depletion  # Sensitivity definition 3: CO selectivity
        if reference_co_sel <= 0:
            reference_co_sel = 1.0e-15  # selectivity can't be 0

        reference_syngas_selectivity = reference_co_sel + reference_h2_sel  # Sensitivity definition 1: SYNGAS selectivity

        reference_syngas_yield = reference_syngas_selectivity * reference_ch4_conv  # Sensitivity definition 2: SYNGAS yield
        if reference_syngas_yield <= 0:
            reference_syngas_yield = 1.0e-15  # yield can't be 0

        reference_co_yield = co_out / ch4_in  # Sensitivity definition 4: CO % yield
        # reference_co_yield = reference_co_sel * reference_ch4_conv

        reference_h2_yield = h2_out / (2 * ch4_in)  # Sensitivity definition 6: H2 % yield
        # reference_h2_yield = reference_h2_sel * reference_ch4_conv

        # Sensitivity definition 8: H2O + CO2 selectivity
        reference_h2o_sel = h2o_out / (ch4_depletion * 2)
        reference_co2_sel = co2_out / ch4_depletion
        if reference_h2o_sel <= 0:
            reference_h2o_sel = 1.0e-15  # H2O selectivity can't be 0
        if reference_co2_sel <= 0:
            reference_co2_sel = 1.0e-15  # CO2 selectivity can't be 0
        reference_full_oxidation_selectivity = reference_h2o_sel + reference_co2_sel

        # Sensitivity definition 9: H2O + CO2 yield
        reference_full_oxidation_yield = reference_full_oxidation_selectivity * reference_ch4_conv

    # Sensitivity definition 10: exit temperature
    reference_exit_temp = T_array_data[-1]

    # Sensitivity definition 11: peak temperature
    reference_peak_temp = max(T_array_data)

    # Sensitivity definition 12: distance to peak temperautre
    reference_peak_temp_dist = dist_array_data[T_array_data.index(max(T_array_data))]

    # run the simulations
    if thermo is True:  # thermo sensitivity stuff, all off by default and was not referenced in the paper
        # this should also be rewritten to be less repetitive
        dH = 1e4 # J/mol
        dk = dH / 8.314  # for the thermo loop, 'dk' is in fact (delta H / R)
        for m in range(surf.n_species):
            s = surf.species(m)
            original_coeffs = s.thermo.coeffs
            perturbed_coeffs = np.ones_like(original_coeffs)
            perturbed_coeffs[0] = original_coeffs[0]
            perturbed_coeffs[1:6] = original_coeffs[1:6]
            perturbed_coeffs[7:13] = original_coeffs[7:13]
            perturbed_coeffs[14] = original_coeffs[14]
            perturbed_coeffs[6] = original_coeffs[6] + dk
            perturbed_coeffs[13] = original_coeffs[13] + dk
            s.thermo = ct.NasaPoly2(100.000, 5000.000, ct.one_atm, perturbed_coeffs)
            surf.modify_species(m, s)
            c = monolithFull(gas, surf, temp, moles_in)  # run the simulation

            gas_out, surf_out, gas_names, surf_names, dist_array, T_array = c  # unpack

            new_amts = []
            for a in range(len(gas_names)):
                new_amts.append([gas_names[a], [gas_out[:, a]]])

            for x in new_amts:
                if x[0] == 'CH4(2)':
                    new_ch4_in = x[1][0][0]
                    new_ch4_out = x[1][0][-1]
                    if new_ch4_out < 0:
                        new_ch4_out = 0.
                    new_ch4_depletion = new_ch4_in - new_ch4_out
                    if new_ch4_depletion <= 1e-8:
                        new_ch4_depletion = 1e-8
                        new_ch4_conv = 1e-8
                    else:
                        new_ch4_conv = new_ch4_depletion / new_ch4_in  # Sensitivity definition 7: CH4 conversion
                if x[0] == 'Ar':
                    ar = x[1][0][-1]
                if x[0] == 'O2(3)':
                    new_o2_in = x[1][0][0]
                    new_o2_out = x[1][0][-1]
                    if new_o2_out < 0:
                        new_o2_out = 0.
                    elif new_o2_out > new_o2_in:
                        new_o2_out = new_o2_in
                    new_o2_depletion = new_o2_in - new_o2_out
                    if new_o2_depletion <= 1.0e-8:
                        new_o2_depletion = 1.0e-8
                        new_o2_conv = 1.0e-8
                    else:
                        new_o2_conv = new_o2_depletion / new_o2_in
                if x[0] == 'CO(7)':
                    new_co_out = x[1][0][-1]
                if x[0] == 'H2(6)':
                    new_h2_out = x[1][0][-1]
                if x[0] == 'H2O(5)':
                    new_h2o_out = x[1][0][-1]
                if x[0] == 'CO2(4)':
                    new_co2_out = x[1][0][-1]

            if new_ch4_conv <= 1e-8:
                new_h2_sel = 1.0e-8
                new_co_sel = 1.0e-8
                new_syngas_selectivity = 1.0e-8
                new_syngas_yield = 1.0e-8
                new_co_yield = 1.0e-8
                new_h2_yield = 1.0e-8
                new_full_oxidation_selectivity = 1.0e-8
                new_full_oxidation_yield = 1.0e-8
                new_o2_conv = 1e-8
            else:
                new_h2_sel = new_h2_out / (new_ch4_depletion * 2)  # Sensitivity definition 5: H2 selectivity
                new_co_sel = new_co_out / new_ch4_depletion  # Sensitivity definition 3: CO selectivity
                new_syngas_selectivity = new_co_sel + new_h2_sel  # Sensitivity definition 1: SYNGAS selectivity
                new_syngas_yield = new_syngas_selectivity * new_ch4_conv  # Sensitivity definition 2: SYNGAS yield
                new_co_yield = new_co_out / new_ch4_in  # Sensitivity definition 4: CO % yield
                new_h2_yield = new_h2_out / (2 * new_ch4_in)  # Sensitivity definition 6: H2 % yield
                new_h2o_sel = new_h2o_out / (new_ch4_depletion * 2)  # Sensitivity definition 8: H2O + CO2 selectivity
                new_co2_sel = new_co2_out / new_ch4_depletion
                new_full_oxidation_selectivity = new_h2o_sel + new_co2_sel
                new_full_oxidation_yield = new_full_oxidation_selectivity * new_ch4_conv  # Sensitivity definition 9: C2O + CO2 yield

            Sens5 = (new_h2_sel - reference_h2_sel) / (reference_h2_sel * dk)
            sens5.append(Sens5)

            Sens3 = (new_co_sel - reference_co_sel) / (reference_co_sel * dk)
            sens3.append(Sens3)

            Sens1 = (new_syngas_selectivity - reference_syngas_selectivity) / (reference_syngas_selectivity * dk)
            sens1.append(Sens1)

            Sens2 = (new_syngas_yield - reference_syngas_yield) / (reference_syngas_yield * dk)
            sens2.append(Sens2)

            Sens4 = (new_co_yield - reference_co_yield) / (reference_co_yield * dk)
            sens4.append(Sens4)

            Sens6 = (new_h2_yield - reference_h2_yield) / (reference_h2_yield * dk)
            sens6.append(Sens6)

            Sens7 = (new_ch4_conv - reference_ch4_conv) / (
                        reference_ch4_conv * dk)
            sens7.append(Sens7)
            
            Sens13 = (new_o2_conv - reference_o2_conv) / (reference_o2_conv * dk)
            sens13.append(Sens13)

            Sens8 = (new_full_oxidation_selectivity - reference_full_oxidation_selectivity) / (
                        reference_full_oxidation_selectivity * dk)
            sens8.append(Sens8)

            Sens9 = (new_full_oxidation_yield - reference_full_oxidation_yield) / (reference_full_oxidation_yield * dk)
            sens9.append(Sens9)

            new_exit_temp = T_array[-1]  # Sensitivity definition 10: exit temperature
            Sens10 = (new_exit_temp - reference_exit_temp) / (reference_exit_temp * dk)
            sens10.append(Sens10)

            new_peak_temp = max(T_array)  # Sensitivity definition 11: peak temperature
            Sens11 = (new_peak_temp - reference_peak_temp) / (reference_peak_temp * dk)
            sens11.append(Sens11)

            new_peak_temp_dist = dist_array[
                T_array.index(max(T_array))]  # Sensitivity definition 12: dist to peak temperature
            Sens12 = (new_peak_temp_dist - reference_peak_temp_dist) / (reference_peak_temp_dist * dk)
            sens12.append(Sens12)

            print "%d %s %.3F %.3F" % (m, surf.species_name(m), Sens1, Sens2)
            rxns.append(surf.species_name(m))

            # this step is essential, otherwise mechanism will have been altered
            s.thermo = ct.NasaPoly2(100.000, 5000.000, ct.one_atm, original_coeffs)
            surf.modify_species(m, s)
    else:  # reaction sensitivity analysis, the DEFAULT
        for rxn in range(surf.n_reactions):
            c = monolithFull(gas, surf, temp, moles_in, sens=[dk, rxn])
            gas_out, surf_out, gas_names, surf_names, dist_array, T_array = c  # unpack

            new_amts = []
            for a in range(len(gas_names)):
                new_amts.append([gas_names[a], [gas_out[:, a]]])

            for x in new_amts:
                if x[0] == 'CH4(2)':
                    new_ch4_in = x[1][0][0]
                    new_ch4_out = x[1][0][-1]
                    if new_ch4_out < 0:
                        new_ch4_out = 0.
                    new_ch4_depletion = new_ch4_in - new_ch4_out
                    if new_ch4_depletion <= 1e-8:
                        new_ch4_depletion = 1e-8
                        new_ch4_conv = 1e-8
                    else:
                        new_ch4_conv = new_ch4_depletion / new_ch4_in  # Sensitivity definition 7: CH4 conversion
                if x[0] == 'Ar':
                    ar = x[1][0][-1]
                if x[0] == 'O2(3)':
                    new_o2_in = x[1][0][0]
                    new_o2_out = x[1][0][-1]
                    if new_o2_out < 0:
                        new_o2_out = 0.
                    elif new_o2_out > new_o2_in:
                        new_o2_out = new_o2_in
                    new_o2_depletion = new_o2_in - new_o2_out
                    if new_o2_depletion <= 1.0e-8:
                        new_o2_depletion = 1.0e-8
                        new_o2_conv = 1.0e-8
                    else:
                        new_o2_conv = new_o2_depletion / new_o2_in
                if x[0] == 'CO(7)':
                    new_co_out = x[1][0][-1]
                if x[0] == 'H2(6)':
                    new_h2_out = x[1][0][-1]
                if x[0] == 'H2O(5)':
                    new_h2o_out = x[1][0][-1]
                if x[0] == 'CO2(4)':
                    new_co2_out = x[1][0][-1]

            if new_ch4_conv <= 1e-8:  # if basically nothing happens, sub in close to zeros so there are no divide by zero errors
                new_h2_sel = 1.0e-8
                new_co_sel = 1.0e-8
                new_syngas_selectivity = 1.0e-8
                new_syngas_yield = 1.0e-8
                new_co_yield = 1.0e-8
                new_h2_yield = 1.0e-8
                new_full_oxidation_selectivity = 1.0e-8
                new_full_oxidation_yield = 1.0e-8
                new_o2_conv = 1.0e-8
            else:
                new_h2_sel = new_h2_out / (new_ch4_depletion * 2)  # Sensitivity definition 5: H2 selectivity
                new_co_sel = new_co_out / new_ch4_depletion  # Sensitivity definition 3: CO selectivity
                new_syngas_selectivity = new_co_sel + new_h2_sel  # Sensitivity definition 1: SYNGAS selectivity
                new_syngas_yield = new_syngas_selectivity * new_ch4_conv  # Sensitivity definition 2: SYNGAS yield
                new_co_yield = new_co_out / new_ch4_in  # Sensitivity definition 4: CO % yield
                new_h2_yield = new_h2_out / (2 * new_ch4_in)  # Sensitivity definition 6: H2 % yield
                new_h2o_sel = new_h2o_out / (new_ch4_depletion * 2)  # Sensitivity definition 8: H2O + CO2 selectivity
                new_co2_sel = new_co2_out / new_ch4_depletion
                new_full_oxidation_selectivity = new_h2o_sel + new_co2_sel
                new_full_oxidation_yield = new_full_oxidation_selectivity * new_ch4_conv  # Sensitivity definition 9: C2O + CO2 yield

            Sens5 = (new_h2_sel - reference_h2_sel) / (reference_h2_sel * dk)
            sens5.append(Sens5)

            Sens3 = (new_co_sel - reference_co_sel) / (reference_co_sel * dk)
            sens3.append(Sens3)

            Sens1 = (new_syngas_selectivity - reference_syngas_selectivity) / (reference_syngas_selectivity * dk)
            sens1.append(Sens1)

            Sens2 = (new_syngas_yield - reference_syngas_yield) / (reference_syngas_yield * dk)
            sens2.append(Sens2)

            Sens4 = (new_co_yield - reference_co_yield) / (reference_co_yield * dk)
            sens4.append(Sens4)

            Sens6 = (new_h2_yield - reference_h2_yield) / (reference_h2_yield * dk)
            sens6.append(Sens6)

            Sens7 = (new_ch4_conv - reference_ch4_conv) / (
                    reference_ch4_conv * dk)
            sens7.append(Sens7)
            
            Sens13 = (new_o2_conv - reference_o2_conv) / (reference_o2_conv * dk)
            sens13.append(Sens13)

            Sens8 = (new_full_oxidation_selectivity - reference_full_oxidation_selectivity) / (
                    reference_full_oxidation_selectivity * dk)
            sens8.append(Sens8)

            Sens9 = (new_full_oxidation_yield - reference_full_oxidation_yield) / (reference_full_oxidation_yield * dk)
            sens9.append(Sens9)

            new_exit_temp = T_array[-1]  # Sensitivity definition 10: exit temperature
            Sens10 = (new_exit_temp - reference_exit_temp) / (reference_exit_temp * dk)
            sens10.append(Sens10)

            new_peak_temp = max(T_array)  # Sensitivity definition 11: peak temperature
            Sens11 = (new_peak_temp - reference_peak_temp) / (reference_peak_temp * dk)
            sens11.append(Sens11)

            new_peak_temp_dist = dist_array[T_array.index(max(T_array))]  # Sensitivity definition 12: dist to peak temperature
            Sens12 = (new_peak_temp_dist - reference_peak_temp_dist) / (reference_peak_temp_dist * dk)
            sens12.append(Sens12)

            print "%d %s %.3F %.3F" % (rxn, surf.reaction_equations()[rxn], Sens1, Sens2)
            rxns.append(surf.reaction_equations()[rxn])

    return rxns, sens1, sens2, sens3, sens4, sens5, sens6, sens7, sens8, sens9, sens10, sens11, sens12, sens13


def export(rxns_translated, ratio, thermo=False):  # export all of the sensitivity simulations to a csv
    k = (pd.DataFrame.from_dict(data=rxns_translated, orient='columns'))
    k.columns = ['Reaction', 'SYNGAS Selec', 'SYNGAS Yield', 'CO Selectivity', 'CO % Yield', 'H2 Selectivity', 'H2 % Yield',
                 'CH4 Conversion', 'H2O+CO2 Selectivity', 'H2O+CO2 yield', 'Exit Temp', 'Peak Temp',
                 'Dist to peak temp', 'O2 Conversion']
    out_dir = 'sensitivities'
    os.path.exists(out_dir) or os.makedirs(out_dir)
    if thermo is True:
        k.to_csv(out_dir + '/{:.1f}ThermoSensitivity.csv'.format(ratio), header=True)
    else:
        k.to_csv(out_dir + '/{:.1f}RxnSensitivity.csv'.format(ratio), header=True)


def sensitivityWorker(data):  # actually run all of the sensitivity simulations
    print('Starting sensitivity simulation for a C/O ratio of {:.1f}'.format(data[0]))
    old_data = data[1][0]
    ratio = data[0]
    try:
        reactions, sensitivity1, sensitivity2, sensitivity3, sensitivity4, sensitivity5, sensitivity6, sensitivity7, sensitivity8, sensitivity9, sensitivity10, sensitivity11, sensitivity12, sensitivity13 = sensitivity(gas, surf, old_data, t_in, dk)
        print('Finished sensitivity simulation for a C/O ratio of {:.1f}'.format(ratio))
        rxns_translated = []
        for x in reactions:  # translate reactions into smiles to make them easier to compare with eachother
            for key, smile in names.iteritems():
                x = re.sub(re.escape(key), smile, x)
            rxns_translated.append(x)
        print('Finished translating for C/O ratio of {:.1f}'.format(ratio))
        output = []
        for x in range(len(rxns_translated)):
            output.append([rxns_translated[x], sensitivity1[x], sensitivity2[x], sensitivity3[x], sensitivity4[x],
                           sensitivity5[x], sensitivity6[x], sensitivity7[x], sensitivity8[x], sensitivity9[x],
                           sensitivity10[x], sensitivity11[x], sensitivity12[x], sensitivity13[x]])
        export(output, ratio)
    except Exception, e: print str(e)
        # print('Unable to run sensitivity simulation at a C/O ratio of {:.1f}'.format(data[0]))
        # pass


def sensitivityThermoWorker(data):  # sensitivity for thermo parameters
    print('Starting thermo sensitivity simulation for a C/O ratio of {:.1f}'.format(data[0]))
    old_data = data[1][0]
    ratio = data[0]
    try:
        species_on_surface, sensitivity1, sensitivity2, sensitivity3, sensitivity4, sensitivity5, sensitivity6, sensitivity7, sensitivity8, sensitivity9, sensitivity10, sensitivity11, sensitivity12, sensitivity13 = sensitivity(gas, surf, old_data, t_in, dk, thermo=True)
        print('Finished thermo sensitivity simulation for a C/O ratio of {:.1f}'.format(ratio))
        species_translated = []
        for x in species_on_surface:  # translating into smiles to make it easier to compare
            for key, smile in names.iteritems():
                x = re.sub(re.escape(key), smile, x)
            species_translated.append(x)
        output = []
        for x in range(len(species_on_surface)):
            output.append([species_translated[x], sensitivity1[x], sensitivity2[x], sensitivity3[x], sensitivity4[x],
                           sensitivity5[x], sensitivity6[x], sensitivity7[x], sensitivity8[x], sensitivity9[x],
                           sensitivity10[x], sensitivity11[x], sensitivity12[x], sensitivity13[x]])
        export(output, ratio, thermo=True)
    except Exception, e: print str(e)
        # print('Unable to run thermo sensitivity simulation at a C/O ratio of {:.1f}'.format(data[0]))
        # pass


species_dict = rmgpy.data.kinetics.KineticsLibrary().getSpecies('species_dictionary.txt')  # import the species dictionary 
keys = species_dict.keys()
# get the first listed smiles string for each molecule
smile = []
for s in species_dict:
    smile.append(species_dict[s].molecule[0])
    if len(species_dict[s].molecule) is not 1:
        print 'There are %d dupllicate smiles for %s:' % (len(species_dict[s].molecule), s)
        for a in range(len(species_dict[s].molecule)):
            print '%s' % (species_dict[s].molecule[a])
# translate the molecules from above into just smiles strings
smiles = []
for s in smile:
    smiles.append(s.toSMILES())
names = dict(zip(keys, smiles))

# actually run the reaction sensitivity analyses
worker_input = []
dk = 1.0e-2
num_threads = len(data)
pool = multiprocessing.Pool(processes=num_threads)
worker_input = []
for r in range(len(data)):
    worker_input.append([data[r][0], [data[r][1]]])
pool.map(sensitivityWorker, worker_input, 1)
pool.close()
pool.join()


# actually run the thermo sensitivity analyses
worker_input = []
sens_thermo = []
dk = 1.0e-2
num_threads = len(data)
pool = multiprocessing.Pool(processes=num_threads)
for r in range(len(data)):
    worker_input.append([data[r][0], [data[r][1]]])
pool.map(sensitivityThermoWorker, worker_input, 1)
